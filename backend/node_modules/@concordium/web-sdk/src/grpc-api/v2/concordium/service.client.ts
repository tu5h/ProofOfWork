// @generated by protobuf-ts 2.9.1 with parameter optimize_code_size
// @generated from protobuf file "v2/concordium/service.proto" (package "concordium.v2", syntax proto3)
// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { Queries } from "./service.js";
import type { DryRunResponse } from "./types.js";
import type { DryRunRequest } from "./types.js";
import type { DuplexStreamingCall } from "@protobuf-ts/runtime-rpc";
import type { WinningBaker } from "./types.js";
import type { EpochRequest } from "./types.js";
import type { BlockCertificates } from "./types.js";
import type { BakerRewardPeriodInfo } from "./types.js";
import type { BlockItem } from "./types.js";
import type { BlockFinalizationSummary } from "./types.js";
import type { ChainParameters } from "./types.js";
import type { AccountTransactionSignHash } from "./types.js";
import type { PreAccountTransaction } from "./types.js";
import type { SendBlockItemRequest } from "./types.js";
import type { NodeInfo } from "./types.js";
import type { PeersInfo } from "./types.js";
import type { DumpRequest } from "./types.js";
import type { BannedPeer } from "./types.js";
import type { PeerToBan } from "./types.js";
import type { BannedPeers } from "./types.js";
import type { IpSocketAddress } from "./types.js";
import type { Timestamp } from "./types.js";
import type { NextUpdateSequenceNumbers } from "./types.js";
import type { PendingUpdate } from "./types.js";
import type { BlockSpecialEvent } from "./types.js";
import type { BlockItemSummary } from "./types.js";
import type { ArInfo } from "./types.js";
import type { IpInfo } from "./types.js";
import type { ElectionInfo } from "./types.js";
import type { Branch } from "./types.js";
import type { DelegatorRewardPeriodInfo } from "./types.js";
import type { DelegatorInfo } from "./types.js";
import type { GetPoolDelegatorsRequest } from "./types.js";
import type { InvokeInstanceResponse } from "./types.js";
import type { InvokeInstanceRequest } from "./types.js";
import type { TokenomicsInfo } from "./types.js";
import type { BlocksAtHeightResponse } from "./types.js";
import type { BlocksAtHeightRequest } from "./types.js";
import type { PassiveDelegationInfo } from "./types.js";
import type { PoolInfoResponse } from "./types.js";
import type { PoolInfoRequest } from "./types.js";
import type { BakerId } from "./types.js";
import type { BlockInfo } from "./types.js";
import type { CryptographicParameters } from "./types.js";
import type { BlockItemStatus } from "./types.js";
import type { TransactionHash } from "./types.js";
import type { ConsensusInfo } from "./types.js";
import type { NextAccountSequenceNumber } from "./types.js";
import type { InstanceStateValueAtKey } from "./types.js";
import type { InstanceStateLookupRequest } from "./types.js";
import type { InstanceStateKVPair } from "./types.js";
import type { InstanceInfo } from "./types.js";
import type { InstanceInfoRequest } from "./types.js";
import type { ContractAddress } from "./types.js";
import type { VersionedModuleSource } from "./types.js";
import type { ModuleSourceRequest } from "./types.js";
import type { BlockHash } from "./types.js";
import type { AncestorsRequest } from "./types.js";
import type { ModuleRef } from "./types.js";
import type { AccountAddress } from "./types.js";
import type { BlockHashInput } from "./types.js";
import type { AccountInfo } from "./types.js";
import type { AccountInfoRequest } from "./types.js";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { FinalizedBlockInfo } from "./types.js";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { ArrivedBlockInfo } from "./types.js";
import type { Empty } from "./types.js";
import type { ServerStreamingCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * @generated from protobuf service concordium.v2.Queries
 */
export interface IQueriesClient {
    /**
     * Return a stream of blocks that arrive from the time the query is made onward.
     * This can be used to listen for incoming blocks.
     *
     * @generated from protobuf rpc: GetBlocks(concordium.v2.Empty) returns (stream concordium.v2.ArrivedBlockInfo);
     */
    getBlocks(input: Empty, options?: RpcOptions): ServerStreamingCall<Empty, ArrivedBlockInfo>;
    /**
     * Return a stream of blocks that are finalized from the time the query is
     * made onward. This can be used to listen for newly finalized blocks. Note
     * that there is no guarantee that blocks will not be skipped if the client is
     * too slow in processing the stream, however blocks will always be sent by
     * increasing block height.
     *
     * @generated from protobuf rpc: GetFinalizedBlocks(concordium.v2.Empty) returns (stream concordium.v2.FinalizedBlockInfo);
     */
    getFinalizedBlocks(input: Empty, options?: RpcOptions): ServerStreamingCall<Empty, FinalizedBlockInfo>;
    /**
     * Retrieve the information about the given account in the given block.
     *
     * @generated from protobuf rpc: GetAccountInfo(concordium.v2.AccountInfoRequest) returns (concordium.v2.AccountInfo);
     */
    getAccountInfo(input: AccountInfoRequest, options?: RpcOptions): UnaryCall<AccountInfoRequest, AccountInfo>;
    /**
     * Retrieve the list of accounts that exist at the end of the given block.
     *
     * @generated from protobuf rpc: GetAccountList(concordium.v2.BlockHashInput) returns (stream concordium.v2.AccountAddress);
     */
    getAccountList(input: BlockHashInput, options?: RpcOptions): ServerStreamingCall<BlockHashInput, AccountAddress>;
    /**
     * Get a list of all smart contract modules. The stream will end
     * when all modules that exist in the state at the end of the given
     * block have been returned.
     *
     * @generated from protobuf rpc: GetModuleList(concordium.v2.BlockHashInput) returns (stream concordium.v2.ModuleRef);
     */
    getModuleList(input: BlockHashInput, options?: RpcOptions): ServerStreamingCall<BlockHashInput, ModuleRef>;
    /**
     * Get a stream of ancestors for the provided block.
     * Starting with the provided block itself, moving backwards until no more
     * ancestors or the requested number of ancestors has been returned.
     *
     * @generated from protobuf rpc: GetAncestors(concordium.v2.AncestorsRequest) returns (stream concordium.v2.BlockHash);
     */
    getAncestors(input: AncestorsRequest, options?: RpcOptions): ServerStreamingCall<AncestorsRequest, BlockHash>;
    /**
     * Get the source of a smart contract module.
     *
     * @generated from protobuf rpc: GetModuleSource(concordium.v2.ModuleSourceRequest) returns (concordium.v2.VersionedModuleSource);
     */
    getModuleSource(input: ModuleSourceRequest, options?: RpcOptions): UnaryCall<ModuleSourceRequest, VersionedModuleSource>;
    /**
     * Get a list of addresses for all smart contract instances. The stream
     * will end when all instances that exist in the state at the end of the
     * given block has been returned.
     *
     * @generated from protobuf rpc: GetInstanceList(concordium.v2.BlockHashInput) returns (stream concordium.v2.ContractAddress);
     */
    getInstanceList(input: BlockHashInput, options?: RpcOptions): ServerStreamingCall<BlockHashInput, ContractAddress>;
    /**
     * Get info about a smart contract instance as it appears at the end of the
     * given block.
     *
     * @generated from protobuf rpc: GetInstanceInfo(concordium.v2.InstanceInfoRequest) returns (concordium.v2.InstanceInfo);
     */
    getInstanceInfo(input: InstanceInfoRequest, options?: RpcOptions): UnaryCall<InstanceInfoRequest, InstanceInfo>;
    /**
     * Get the exact state of a specific contract instance, streamed as a list of
     * key-value pairs. The list is streamed in lexicographic order of keys.
     *
     * @generated from protobuf rpc: GetInstanceState(concordium.v2.InstanceInfoRequest) returns (stream concordium.v2.InstanceStateKVPair);
     */
    getInstanceState(input: InstanceInfoRequest, options?: RpcOptions): ServerStreamingCall<InstanceInfoRequest, InstanceStateKVPair>;
    /**
     * Get the value at a specific key of a contract state. In contrast to
     * `GetInstanceState` this is more efficient, but requires the user to know
     * the specific key to look for.
     *
     * @generated from protobuf rpc: InstanceStateLookup(concordium.v2.InstanceStateLookupRequest) returns (concordium.v2.InstanceStateValueAtKey);
     */
    instanceStateLookup(input: InstanceStateLookupRequest, options?: RpcOptions): UnaryCall<InstanceStateLookupRequest, InstanceStateValueAtKey>;
    /**
     * Get the best guess as to what the next account sequence number should be.
     * If all account transactions are finalized then this information is reliable.
     * Otherwise this is the best guess, assuming all other transactions will be
     * committed to blocks and eventually finalized.
     *
     * @generated from protobuf rpc: GetNextAccountSequenceNumber(concordium.v2.AccountAddress) returns (concordium.v2.NextAccountSequenceNumber);
     */
    getNextAccountSequenceNumber(input: AccountAddress, options?: RpcOptions): UnaryCall<AccountAddress, NextAccountSequenceNumber>;
    /**
     * Get information about the current state of consensus.
     *
     * @generated from protobuf rpc: GetConsensusInfo(concordium.v2.Empty) returns (concordium.v2.ConsensusInfo);
     */
    getConsensusInfo(input: Empty, options?: RpcOptions): UnaryCall<Empty, ConsensusInfo>;
    /**
     * Get the status of and information about a specific block item (transaction).
     *
     * @generated from protobuf rpc: GetBlockItemStatus(concordium.v2.TransactionHash) returns (concordium.v2.BlockItemStatus);
     */
    getBlockItemStatus(input: TransactionHash, options?: RpcOptions): UnaryCall<TransactionHash, BlockItemStatus>;
    /**
     * Get the cryptographic parameters in a given block.
     *
     * @generated from protobuf rpc: GetCryptographicParameters(concordium.v2.BlockHashInput) returns (concordium.v2.CryptographicParameters);
     */
    getCryptographicParameters(input: BlockHashInput, options?: RpcOptions): UnaryCall<BlockHashInput, CryptographicParameters>;
    /**
     * Get information, such as height, timings, and transaction counts for the given block.
     *
     * @generated from protobuf rpc: GetBlockInfo(concordium.v2.BlockHashInput) returns (concordium.v2.BlockInfo);
     */
    getBlockInfo(input: BlockHashInput, options?: RpcOptions): UnaryCall<BlockHashInput, BlockInfo>;
    /**
     * Get all the bakers at the end of the given block.
     *
     * @generated from protobuf rpc: GetBakerList(concordium.v2.BlockHashInput) returns (stream concordium.v2.BakerId);
     */
    getBakerList(input: BlockHashInput, options?: RpcOptions): ServerStreamingCall<BlockHashInput, BakerId>;
    /**
     * Get information about a given pool at the end of a given block.
     *
     * @generated from protobuf rpc: GetPoolInfo(concordium.v2.PoolInfoRequest) returns (concordium.v2.PoolInfoResponse);
     */
    getPoolInfo(input: PoolInfoRequest, options?: RpcOptions): UnaryCall<PoolInfoRequest, PoolInfoResponse>;
    /**
     * Get information about the passive delegators at the end of a given block.
     *
     * @generated from protobuf rpc: GetPassiveDelegationInfo(concordium.v2.BlockHashInput) returns (concordium.v2.PassiveDelegationInfo);
     */
    getPassiveDelegationInfo(input: BlockHashInput, options?: RpcOptions): UnaryCall<BlockHashInput, PassiveDelegationInfo>;
    /**
     * Get a list of live blocks at a given height.
     *
     * @generated from protobuf rpc: GetBlocksAtHeight(concordium.v2.BlocksAtHeightRequest) returns (concordium.v2.BlocksAtHeightResponse);
     */
    getBlocksAtHeight(input: BlocksAtHeightRequest, options?: RpcOptions): UnaryCall<BlocksAtHeightRequest, BlocksAtHeightResponse>;
    /**
     * Get information about tokenomics at the end of a given block.
     *
     * @generated from protobuf rpc: GetTokenomicsInfo(concordium.v2.BlockHashInput) returns (concordium.v2.TokenomicsInfo);
     */
    getTokenomicsInfo(input: BlockHashInput, options?: RpcOptions): UnaryCall<BlockHashInput, TokenomicsInfo>;
    /**
     * Run the smart contract entrypoint in a given context and in the state at
     * the end of the given block.
     *
     * @generated from protobuf rpc: InvokeInstance(concordium.v2.InvokeInstanceRequest) returns (concordium.v2.InvokeInstanceResponse);
     */
    invokeInstance(input: InvokeInstanceRequest, options?: RpcOptions): UnaryCall<InvokeInstanceRequest, InvokeInstanceResponse>;
    /**
     * Get the registered delegators of a given pool at the end of a given block.
     * In contrast to the `GetPoolDelegatorsRewardPeriod` which returns delegators
     * that are fixed for the reward period of the block, this endpoint returns the
     * list of delegators that are registered in the block. Any changes to delegators
     * are immediately visible in this list.
     * The stream will end when all the delegators has been returned.
     *
     * @generated from protobuf rpc: GetPoolDelegators(concordium.v2.GetPoolDelegatorsRequest) returns (stream concordium.v2.DelegatorInfo);
     */
    getPoolDelegators(input: GetPoolDelegatorsRequest, options?: RpcOptions): ServerStreamingCall<GetPoolDelegatorsRequest, DelegatorInfo>;
    /**
     * Get the fixed delegators of a given pool for the reward period of the given block.
     * In contracts to the `GetPoolDelegators` which returns delegators registered
     * for the given block, this endpoint returns the fixed delegators contributing
     * stake in the reward period containing the given block.
     * The stream will end when all the delegators has been returned.
     *
     * @generated from protobuf rpc: GetPoolDelegatorsRewardPeriod(concordium.v2.GetPoolDelegatorsRequest) returns (stream concordium.v2.DelegatorRewardPeriodInfo);
     */
    getPoolDelegatorsRewardPeriod(input: GetPoolDelegatorsRequest, options?: RpcOptions): ServerStreamingCall<GetPoolDelegatorsRequest, DelegatorRewardPeriodInfo>;
    /**
     * Get the registered passive delegators at the end of a given block.
     * In contrast to the `GetPassiveDelegatorsRewardPeriod` which returns delegators
     * that are fixed for the reward period of the block, this endpoint returns the
     * list of delegators that are registered in the block. Any changes to delegators
     * are immediately visible in this list.
     * The stream will end when all the delegators has been returned.
     *
     * @generated from protobuf rpc: GetPassiveDelegators(concordium.v2.BlockHashInput) returns (stream concordium.v2.DelegatorInfo);
     */
    getPassiveDelegators(input: BlockHashInput, options?: RpcOptions): ServerStreamingCall<BlockHashInput, DelegatorInfo>;
    /**
     * Get the fixed passive delegators for the reward period of the given block.
     * In contracts to the `GetPassiveDelegators` which returns delegators registered
     * for the given block, this endpoint returns the fixed delegators contributing
     * stake in the reward period containing the given block.
     * The stream will end when all the delegators has been returned.
     *
     * @generated from protobuf rpc: GetPassiveDelegatorsRewardPeriod(concordium.v2.BlockHashInput) returns (stream concordium.v2.DelegatorRewardPeriodInfo);
     */
    getPassiveDelegatorsRewardPeriod(input: BlockHashInput, options?: RpcOptions): ServerStreamingCall<BlockHashInput, DelegatorRewardPeriodInfo>;
    /**
     * Get the current branches of blocks starting from and including the last finalized block.
     *
     * @generated from protobuf rpc: GetBranches(concordium.v2.Empty) returns (concordium.v2.Branch);
     */
    getBranches(input: Empty, options?: RpcOptions): UnaryCall<Empty, Branch>;
    /**
     * Get information related to the baker election for a particular block.
     *
     * @generated from protobuf rpc: GetElectionInfo(concordium.v2.BlockHashInput) returns (concordium.v2.ElectionInfo);
     */
    getElectionInfo(input: BlockHashInput, options?: RpcOptions): UnaryCall<BlockHashInput, ElectionInfo>;
    /**
     * Get the identity providers registered as of the end of a given block.
     * The stream will end when all the identity providers have been returned.
     *
     * @generated from protobuf rpc: GetIdentityProviders(concordium.v2.BlockHashInput) returns (stream concordium.v2.IpInfo);
     */
    getIdentityProviders(input: BlockHashInput, options?: RpcOptions): ServerStreamingCall<BlockHashInput, IpInfo>;
    /**
     * Get the anonymity revokers registered as of the end of a given block.
     * The stream will end when all the anonymity revokers have been returned.
     *
     * @generated from protobuf rpc: GetAnonymityRevokers(concordium.v2.BlockHashInput) returns (stream concordium.v2.ArInfo);
     */
    getAnonymityRevokers(input: BlockHashInput, options?: RpcOptions): ServerStreamingCall<BlockHashInput, ArInfo>;
    /**
     * Get a list of non-finalized transaction hashes for a given account. This
     * endpoint is not expected to return a large amount of data in most cases,
     * but in bad network condtions it might. The stream will end when all the
     * non-finalized transaction hashes have been returned.
     *
     * @generated from protobuf rpc: GetAccountNonFinalizedTransactions(concordium.v2.AccountAddress) returns (stream concordium.v2.TransactionHash);
     */
    getAccountNonFinalizedTransactions(input: AccountAddress, options?: RpcOptions): ServerStreamingCall<AccountAddress, TransactionHash>;
    /**
     * Get a list of transaction events in a given block.
     * The stream will end when all the transaction events for a given block have been returned.
     *
     * @generated from protobuf rpc: GetBlockTransactionEvents(concordium.v2.BlockHashInput) returns (stream concordium.v2.BlockItemSummary);
     */
    getBlockTransactionEvents(input: BlockHashInput, options?: RpcOptions): ServerStreamingCall<BlockHashInput, BlockItemSummary>;
    /**
     * Get a list of special events in a given block. These are events generated
     * by the protocol, such as minting and reward payouts. They are not directly
     * generated by any transaction. The stream will end when all the special
     * events for a given block have been returned.
     *
     * @generated from protobuf rpc: GetBlockSpecialEvents(concordium.v2.BlockHashInput) returns (stream concordium.v2.BlockSpecialEvent);
     */
    getBlockSpecialEvents(input: BlockHashInput, options?: RpcOptions): ServerStreamingCall<BlockHashInput, BlockSpecialEvent>;
    /**
     * Get the pending updates to chain parameters at the end of a given block.
     * The stream will end when all the pending updates for a given block have been returned.
     *
     * @generated from protobuf rpc: GetBlockPendingUpdates(concordium.v2.BlockHashInput) returns (stream concordium.v2.PendingUpdate);
     */
    getBlockPendingUpdates(input: BlockHashInput, options?: RpcOptions): ServerStreamingCall<BlockHashInput, PendingUpdate>;
    /**
     * Get next available sequence numbers for updating chain parameters after a given block.
     *
     * @generated from protobuf rpc: GetNextUpdateSequenceNumbers(concordium.v2.BlockHashInput) returns (concordium.v2.NextUpdateSequenceNumbers);
     */
    getNextUpdateSequenceNumbers(input: BlockHashInput, options?: RpcOptions): UnaryCall<BlockHashInput, NextUpdateSequenceNumbers>;
    /**
     * Get the projected earliest time at which a particular baker will be required to bake a block.
     * If the current consensus version is 0, this returns the status 'Unavailable', as the endpoint
     * is only supported by consensus version 1.
     *
     * If the baker is not a baker for the current reward period, this returns a timestamp at the
     * start of the next reward period. If the baker is a baker for the current reward period, the
     * earliest win time is projected from the current round forward, assuming that each round after
     * the last finalized round will take the minimum block time. (If blocks take longer, or timeouts
     * occur, the actual time may be later, and the reported time in subsequent queries may reflect
     * this.) At the end of an epoch (or if the baker is not projected to bake before the end of the
     * epoch) the earliest win time for a (current) baker will be projected as the start of the next
     * epoch. This is because the seed for the leader election is updated at the epoch boundary, and
     * so the winners cannot be predicted beyond that. Note that in some circumstances the returned
     * timestamp can be in the past, especially at the end of an epoch.
     *
     * @generated from protobuf rpc: GetBakerEarliestWinTime(concordium.v2.BakerId) returns (concordium.v2.Timestamp);
     */
    getBakerEarliestWinTime(input: BakerId, options?: RpcOptions): UnaryCall<BakerId, Timestamp>;
    /**
     * Shut down the node.
     * Return a GRPC error if the shutdown failed.
     *
     * @generated from protobuf rpc: Shutdown(concordium.v2.Empty) returns (concordium.v2.Empty);
     */
    shutdown(input: Empty, options?: RpcOptions): UnaryCall<Empty, Empty>;
    /**
     * Suggest to a peer to connect to the submitted peer details.
     * This, if successful, adds the peer to the list of given addresses.
     * Otherwise return a GRPC error.
     * Note. The peer might not be connected to instantly, in that case
     * the node will try to establish the connection in near future. This
     * function returns a GRPC status 'Ok' in this case.
     *
     * @generated from protobuf rpc: PeerConnect(concordium.v2.IpSocketAddress) returns (concordium.v2.Empty);
     */
    peerConnect(input: IpSocketAddress, options?: RpcOptions): UnaryCall<IpSocketAddress, Empty>;
    /**
     * Disconnect from the peer and remove them from the given addresses list
     * if they are on it. Return if the request was processed successfully.
     * Otherwise return a GRPC error.
     *
     * @generated from protobuf rpc: PeerDisconnect(concordium.v2.IpSocketAddress) returns (concordium.v2.Empty);
     */
    peerDisconnect(input: IpSocketAddress, options?: RpcOptions): UnaryCall<IpSocketAddress, Empty>;
    /**
     * Get a list of banned peers.
     *
     * @generated from protobuf rpc: GetBannedPeers(concordium.v2.Empty) returns (concordium.v2.BannedPeers);
     */
    getBannedPeers(input: Empty, options?: RpcOptions): UnaryCall<Empty, BannedPeers>;
    /**
     * Ban the given peer.
     * Returns a GRPC error if the action failed.
     *
     * @generated from protobuf rpc: BanPeer(concordium.v2.PeerToBan) returns (concordium.v2.Empty);
     */
    banPeer(input: PeerToBan, options?: RpcOptions): UnaryCall<PeerToBan, Empty>;
    /**
     * Unban the banned peer.
     * Returns a GRPC error if the action failed.
     *
     * @generated from protobuf rpc: UnbanPeer(concordium.v2.BannedPeer) returns (concordium.v2.Empty);
     */
    unbanPeer(input: BannedPeer, options?: RpcOptions): UnaryCall<BannedPeer, Empty>;
    /**
     * Start dumping packages into the specified file.
     * Only enabled if the node was built with the `network_dump` feature.
     * Returns a GRPC error if the network dump failed to start.
     *
     * @generated from protobuf rpc: DumpStart(concordium.v2.DumpRequest) returns (concordium.v2.Empty);
     */
    dumpStart(input: DumpRequest, options?: RpcOptions): UnaryCall<DumpRequest, Empty>;
    /**
     * Stop dumping packages.
     * Only enabled if the node was built with the `network_dump` feature.
     * Returns a GRPC error if the network dump failed to be stopped.
     *
     * @generated from protobuf rpc: DumpStop(concordium.v2.Empty) returns (concordium.v2.Empty);
     */
    dumpStop(input: Empty, options?: RpcOptions): UnaryCall<Empty, Empty>;
    /**
     * / Get a list of the peers that the node is connected to
     * / and assoicated network related information for each peer.
     *
     * @generated from protobuf rpc: GetPeersInfo(concordium.v2.Empty) returns (concordium.v2.PeersInfo);
     */
    getPeersInfo(input: Empty, options?: RpcOptions): UnaryCall<Empty, PeersInfo>;
    /**
     * Get information about the node.
     * The `NodeInfo` includes information of
     * * Meta information such as the, version of the node, type of the node, uptime and the local time of the node.
     * * NetworkInfo which yields data such as the node id, packets sent/received,
     *   average bytes per second sent/received.
     * * ConsensusInfo. The `ConsensusInfo` returned depends on if the node supports
     *   the protocol on chain and whether the node is configured as a baker or not.
     *
     * @generated from protobuf rpc: GetNodeInfo(concordium.v2.Empty) returns (concordium.v2.NodeInfo);
     */
    getNodeInfo(input: Empty, options?: RpcOptions): UnaryCall<Empty, NodeInfo>;
    /**
     * Send a block item. A block item is either an `AccountTransaction`, which is
     * a transaction signed and paid for by an account, a `CredentialDeployment`,
     * which creates a new account, or `UpdateInstruction`, which is an
     * instruction to change some parameters of the chain. Update instructions can
     * only be sent by the governance committee.
     *
     * Returns a hash of the block item, which can be used with
     * `GetBlockItemStatus`.
     *
     * @generated from protobuf rpc: SendBlockItem(concordium.v2.SendBlockItemRequest) returns (concordium.v2.TransactionHash);
     */
    sendBlockItem(input: SendBlockItemRequest, options?: RpcOptions): UnaryCall<SendBlockItemRequest, TransactionHash>;
    /**
     * Get the hash to be signed for an account transaction. The hash returned
     * should be signed and the signatures included as an
     * AccountTransactionSignature when calling `SendBlockItem`. This is provided as
     * a convenience to support cases where the right SDK is not available for
     * interacting with the node. If an SDK is available then it is strongly
     * recommended to compute this hash off-line using it. That reduces the trust
     * in the node, removes networking failure modes, and will perform better.
     *
     * @generated from protobuf rpc: GetAccountTransactionSignHash(concordium.v2.PreAccountTransaction) returns (concordium.v2.AccountTransactionSignHash);
     */
    getAccountTransactionSignHash(input: PreAccountTransaction, options?: RpcOptions): UnaryCall<PreAccountTransaction, AccountTransactionSignHash>;
    /**
     * Get the values of chain parameters in effect in the given block.
     *
     * @generated from protobuf rpc: GetBlockChainParameters(concordium.v2.BlockHashInput) returns (concordium.v2.ChainParameters);
     */
    getBlockChainParameters(input: BlockHashInput, options?: RpcOptions): UnaryCall<BlockHashInput, ChainParameters>;
    /**
     * Get the summary of the finalization data in a given block.
     *
     * @generated from protobuf rpc: GetBlockFinalizationSummary(concordium.v2.BlockHashInput) returns (concordium.v2.BlockFinalizationSummary);
     */
    getBlockFinalizationSummary(input: BlockHashInput, options?: RpcOptions): UnaryCall<BlockHashInput, BlockFinalizationSummary>;
    /**
     * Get the items of a block.
     *
     * @generated from protobuf rpc: GetBlockItems(concordium.v2.BlockHashInput) returns (stream concordium.v2.BlockItem);
     */
    getBlockItems(input: BlockHashInput, options?: RpcOptions): ServerStreamingCall<BlockHashInput, BlockItem>;
    /**
     * Get all bakers in the reward period of a block.
     * This endpoint is only supported for protocol version 6 and onwards.
     * If the protocol does not support the endpoint then an  'IllegalArgument' error is returned.
     *
     * @generated from protobuf rpc: GetBakersRewardPeriod(concordium.v2.BlockHashInput) returns (stream concordium.v2.BakerRewardPeriodInfo);
     */
    getBakersRewardPeriod(input: BlockHashInput, options?: RpcOptions): ServerStreamingCall<BlockHashInput, BakerRewardPeriodInfo>;
    /**
     * For a non-genesis block, this returns the quorum certificate, a timeout
     * certificate (if present) and epoch finalization entry (if present).
     * Note that, if the block being pointed to is not a product of ConcordiumBFT,
     * then the response will be a grpc error (invalid argument).
     * If the endpoint is not enabled by the node, then an 'unimplemented' error
     * will be returned.
     *
     * @generated from protobuf rpc: GetBlockCertificates(concordium.v2.BlockHashInput) returns (concordium.v2.BlockCertificates);
     */
    getBlockCertificates(input: BlockHashInput, options?: RpcOptions): UnaryCall<BlockHashInput, BlockCertificates>;
    /**
     * Get the list of bakers that won the lottery in a particular historical epoch (i.e. the
     * last finalized block is in a later epoch). This lists the winners for each round in the
     * epoch, starting from the round after the last block in the previous epoch, running to
     * the round before the first block in the next epoch. It also indicates if a block in each
     * round was included in the finalized chain.
     *
     * The following error cases are possible:
     *  * `NOT_FOUND` if the query specifies an unknown block.
     *  * `UNAVAILABLE` if the query is for an epoch that is not finalized in the current genesis
     * /    index, or is for a future genesis index.
     *  * `INVALID_ARGUMENT` if the query is for an epoch that is not finalized for a past genesis
     *    index.
     *  * `INVALID_ARGUMENT` if the query is for a genesis index at consensus version 0.
     *  * `INVALID_ARGUMENT` if the input `EpochRequest` is malformed.
     *  * `UNIMPLEMENTED` if the endpoint is disabled on the node.
     *
     * @generated from protobuf rpc: GetWinningBakersEpoch(concordium.v2.EpochRequest) returns (stream concordium.v2.WinningBaker);
     */
    getWinningBakersEpoch(input: EpochRequest, options?: RpcOptions): ServerStreamingCall<EpochRequest, WinningBaker>;
    /**
     * Get the block hash of the first finalized block in a specified epoch.
     *
     * The following error cases are possible:
     *  * `NOT_FOUND` if the query specifies an unknown block.
     *  * `UNAVAILABLE` if the query is for an epoch that is not finalized in the current genesis
     *    index, or is for a future genesis index.
     *  * `INVALID_ARGUMENT` if the query is for an epoch with no finalized blocks for a past genesis
     *    index.
     *  * `INVALID_ARGUMENT` if the input `EpochRequest` is malformed.
     *  * `UNIMPLEMENTED` if the endpoint is disabled on the node.
     *
     * @generated from protobuf rpc: GetFirstBlockEpoch(concordium.v2.EpochRequest) returns (concordium.v2.BlockHash);
     */
    getFirstBlockEpoch(input: EpochRequest, options?: RpcOptions): UnaryCall<EpochRequest, BlockHash>;
    /**
     * Dry run a series of transactions and operations on a state derived from a specified block.
     * The server should send a single `DryRunResponse` for each `DryRunRequest` received, unless
     * the call fails with an error status code. If a request produces a `DryRunErrorResponse`, then
     * the server will still process subsequent requests, just as if the request causing the error
     * did not happen.
     *
     * The first request should be `load_block_at_state` to determine the block state that will be
     * used for the dry run.
     *
     * The server associates each request with an energy cost, and limits the total energy that may
     * be expended in a single invocation of `DryRun`. This limit is reported as `quota` in the
     * initial metadata returned by the server. If executing an operation exceeds the limit,
     * the server terminates the session with `RESOURCE_EXHAUSTED`.
     *
     * The server also imposes a timeout for a dry-run session to complete. The server reports
     * the timeout duration in milliseconds in the initial metadata field `timeout`. If the session
     * is not completed before the timeout elapses, the server terminates the session with
     * `DEADLINE_EXCEEDED`.
     *
     * The following error cases are possible:
     *  * `INVALID_ARGUMENT` if any `DryRunRequest` is malformed.
     *  * `RESOURCE_EXHAUSTED` if the energy quota is exceeded.
     *  * `DEADLINE_EXCEEDED` if the session does not complete before the server-imposed timeout.
     *  * `RESOURCE_EXHAUSTED` if the server is not currently accepting new `DryRun` sessions.
     *    (The server may impose a limit on the number of concurrent sessions.)
     *  * `INTERNAL` if an interal server error occurs. This should not happen, and likely indicates
     *    a bug.
     *  * `UNIMPLEMENTED` if the endpoint is disabled on the node.
     *
     * @generated from protobuf rpc: DryRun(stream concordium.v2.DryRunRequest) returns (stream concordium.v2.DryRunResponse);
     */
    dryRun(options?: RpcOptions): DuplexStreamingCall<DryRunRequest, DryRunResponse>;
}
/**
 * @generated from protobuf service concordium.v2.Queries
 */
export class QueriesClient implements IQueriesClient, ServiceInfo {
    typeName = Queries.typeName;
    methods = Queries.methods;
    options = Queries.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * Return a stream of blocks that arrive from the time the query is made onward.
     * This can be used to listen for incoming blocks.
     *
     * @generated from protobuf rpc: GetBlocks(concordium.v2.Empty) returns (stream concordium.v2.ArrivedBlockInfo);
     */
    getBlocks(input: Empty, options?: RpcOptions): ServerStreamingCall<Empty, ArrivedBlockInfo> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<Empty, ArrivedBlockInfo>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Return a stream of blocks that are finalized from the time the query is
     * made onward. This can be used to listen for newly finalized blocks. Note
     * that there is no guarantee that blocks will not be skipped if the client is
     * too slow in processing the stream, however blocks will always be sent by
     * increasing block height.
     *
     * @generated from protobuf rpc: GetFinalizedBlocks(concordium.v2.Empty) returns (stream concordium.v2.FinalizedBlockInfo);
     */
    getFinalizedBlocks(input: Empty, options?: RpcOptions): ServerStreamingCall<Empty, FinalizedBlockInfo> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<Empty, FinalizedBlockInfo>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Retrieve the information about the given account in the given block.
     *
     * @generated from protobuf rpc: GetAccountInfo(concordium.v2.AccountInfoRequest) returns (concordium.v2.AccountInfo);
     */
    getAccountInfo(input: AccountInfoRequest, options?: RpcOptions): UnaryCall<AccountInfoRequest, AccountInfo> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<AccountInfoRequest, AccountInfo>("unary", this._transport, method, opt, input);
    }
    /**
     * Retrieve the list of accounts that exist at the end of the given block.
     *
     * @generated from protobuf rpc: GetAccountList(concordium.v2.BlockHashInput) returns (stream concordium.v2.AccountAddress);
     */
    getAccountList(input: BlockHashInput, options?: RpcOptions): ServerStreamingCall<BlockHashInput, AccountAddress> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<BlockHashInput, AccountAddress>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get a list of all smart contract modules. The stream will end
     * when all modules that exist in the state at the end of the given
     * block have been returned.
     *
     * @generated from protobuf rpc: GetModuleList(concordium.v2.BlockHashInput) returns (stream concordium.v2.ModuleRef);
     */
    getModuleList(input: BlockHashInput, options?: RpcOptions): ServerStreamingCall<BlockHashInput, ModuleRef> {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept<BlockHashInput, ModuleRef>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get a stream of ancestors for the provided block.
     * Starting with the provided block itself, moving backwards until no more
     * ancestors or the requested number of ancestors has been returned.
     *
     * @generated from protobuf rpc: GetAncestors(concordium.v2.AncestorsRequest) returns (stream concordium.v2.BlockHash);
     */
    getAncestors(input: AncestorsRequest, options?: RpcOptions): ServerStreamingCall<AncestorsRequest, BlockHash> {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        return stackIntercept<AncestorsRequest, BlockHash>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get the source of a smart contract module.
     *
     * @generated from protobuf rpc: GetModuleSource(concordium.v2.ModuleSourceRequest) returns (concordium.v2.VersionedModuleSource);
     */
    getModuleSource(input: ModuleSourceRequest, options?: RpcOptions): UnaryCall<ModuleSourceRequest, VersionedModuleSource> {
        const method = this.methods[6], opt = this._transport.mergeOptions(options);
        return stackIntercept<ModuleSourceRequest, VersionedModuleSource>("unary", this._transport, method, opt, input);
    }
    /**
     * Get a list of addresses for all smart contract instances. The stream
     * will end when all instances that exist in the state at the end of the
     * given block has been returned.
     *
     * @generated from protobuf rpc: GetInstanceList(concordium.v2.BlockHashInput) returns (stream concordium.v2.ContractAddress);
     */
    getInstanceList(input: BlockHashInput, options?: RpcOptions): ServerStreamingCall<BlockHashInput, ContractAddress> {
        const method = this.methods[7], opt = this._transport.mergeOptions(options);
        return stackIntercept<BlockHashInput, ContractAddress>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get info about a smart contract instance as it appears at the end of the
     * given block.
     *
     * @generated from protobuf rpc: GetInstanceInfo(concordium.v2.InstanceInfoRequest) returns (concordium.v2.InstanceInfo);
     */
    getInstanceInfo(input: InstanceInfoRequest, options?: RpcOptions): UnaryCall<InstanceInfoRequest, InstanceInfo> {
        const method = this.methods[8], opt = this._transport.mergeOptions(options);
        return stackIntercept<InstanceInfoRequest, InstanceInfo>("unary", this._transport, method, opt, input);
    }
    /**
     * Get the exact state of a specific contract instance, streamed as a list of
     * key-value pairs. The list is streamed in lexicographic order of keys.
     *
     * @generated from protobuf rpc: GetInstanceState(concordium.v2.InstanceInfoRequest) returns (stream concordium.v2.InstanceStateKVPair);
     */
    getInstanceState(input: InstanceInfoRequest, options?: RpcOptions): ServerStreamingCall<InstanceInfoRequest, InstanceStateKVPair> {
        const method = this.methods[9], opt = this._transport.mergeOptions(options);
        return stackIntercept<InstanceInfoRequest, InstanceStateKVPair>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get the value at a specific key of a contract state. In contrast to
     * `GetInstanceState` this is more efficient, but requires the user to know
     * the specific key to look for.
     *
     * @generated from protobuf rpc: InstanceStateLookup(concordium.v2.InstanceStateLookupRequest) returns (concordium.v2.InstanceStateValueAtKey);
     */
    instanceStateLookup(input: InstanceStateLookupRequest, options?: RpcOptions): UnaryCall<InstanceStateLookupRequest, InstanceStateValueAtKey> {
        const method = this.methods[10], opt = this._transport.mergeOptions(options);
        return stackIntercept<InstanceStateLookupRequest, InstanceStateValueAtKey>("unary", this._transport, method, opt, input);
    }
    /**
     * Get the best guess as to what the next account sequence number should be.
     * If all account transactions are finalized then this information is reliable.
     * Otherwise this is the best guess, assuming all other transactions will be
     * committed to blocks and eventually finalized.
     *
     * @generated from protobuf rpc: GetNextAccountSequenceNumber(concordium.v2.AccountAddress) returns (concordium.v2.NextAccountSequenceNumber);
     */
    getNextAccountSequenceNumber(input: AccountAddress, options?: RpcOptions): UnaryCall<AccountAddress, NextAccountSequenceNumber> {
        const method = this.methods[11], opt = this._transport.mergeOptions(options);
        return stackIntercept<AccountAddress, NextAccountSequenceNumber>("unary", this._transport, method, opt, input);
    }
    /**
     * Get information about the current state of consensus.
     *
     * @generated from protobuf rpc: GetConsensusInfo(concordium.v2.Empty) returns (concordium.v2.ConsensusInfo);
     */
    getConsensusInfo(input: Empty, options?: RpcOptions): UnaryCall<Empty, ConsensusInfo> {
        const method = this.methods[12], opt = this._transport.mergeOptions(options);
        return stackIntercept<Empty, ConsensusInfo>("unary", this._transport, method, opt, input);
    }
    /**
     * Get the status of and information about a specific block item (transaction).
     *
     * @generated from protobuf rpc: GetBlockItemStatus(concordium.v2.TransactionHash) returns (concordium.v2.BlockItemStatus);
     */
    getBlockItemStatus(input: TransactionHash, options?: RpcOptions): UnaryCall<TransactionHash, BlockItemStatus> {
        const method = this.methods[13], opt = this._transport.mergeOptions(options);
        return stackIntercept<TransactionHash, BlockItemStatus>("unary", this._transport, method, opt, input);
    }
    /**
     * Get the cryptographic parameters in a given block.
     *
     * @generated from protobuf rpc: GetCryptographicParameters(concordium.v2.BlockHashInput) returns (concordium.v2.CryptographicParameters);
     */
    getCryptographicParameters(input: BlockHashInput, options?: RpcOptions): UnaryCall<BlockHashInput, CryptographicParameters> {
        const method = this.methods[14], opt = this._transport.mergeOptions(options);
        return stackIntercept<BlockHashInput, CryptographicParameters>("unary", this._transport, method, opt, input);
    }
    /**
     * Get information, such as height, timings, and transaction counts for the given block.
     *
     * @generated from protobuf rpc: GetBlockInfo(concordium.v2.BlockHashInput) returns (concordium.v2.BlockInfo);
     */
    getBlockInfo(input: BlockHashInput, options?: RpcOptions): UnaryCall<BlockHashInput, BlockInfo> {
        const method = this.methods[15], opt = this._transport.mergeOptions(options);
        return stackIntercept<BlockHashInput, BlockInfo>("unary", this._transport, method, opt, input);
    }
    /**
     * Get all the bakers at the end of the given block.
     *
     * @generated from protobuf rpc: GetBakerList(concordium.v2.BlockHashInput) returns (stream concordium.v2.BakerId);
     */
    getBakerList(input: BlockHashInput, options?: RpcOptions): ServerStreamingCall<BlockHashInput, BakerId> {
        const method = this.methods[16], opt = this._transport.mergeOptions(options);
        return stackIntercept<BlockHashInput, BakerId>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get information about a given pool at the end of a given block.
     *
     * @generated from protobuf rpc: GetPoolInfo(concordium.v2.PoolInfoRequest) returns (concordium.v2.PoolInfoResponse);
     */
    getPoolInfo(input: PoolInfoRequest, options?: RpcOptions): UnaryCall<PoolInfoRequest, PoolInfoResponse> {
        const method = this.methods[17], opt = this._transport.mergeOptions(options);
        return stackIntercept<PoolInfoRequest, PoolInfoResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Get information about the passive delegators at the end of a given block.
     *
     * @generated from protobuf rpc: GetPassiveDelegationInfo(concordium.v2.BlockHashInput) returns (concordium.v2.PassiveDelegationInfo);
     */
    getPassiveDelegationInfo(input: BlockHashInput, options?: RpcOptions): UnaryCall<BlockHashInput, PassiveDelegationInfo> {
        const method = this.methods[18], opt = this._transport.mergeOptions(options);
        return stackIntercept<BlockHashInput, PassiveDelegationInfo>("unary", this._transport, method, opt, input);
    }
    /**
     * Get a list of live blocks at a given height.
     *
     * @generated from protobuf rpc: GetBlocksAtHeight(concordium.v2.BlocksAtHeightRequest) returns (concordium.v2.BlocksAtHeightResponse);
     */
    getBlocksAtHeight(input: BlocksAtHeightRequest, options?: RpcOptions): UnaryCall<BlocksAtHeightRequest, BlocksAtHeightResponse> {
        const method = this.methods[19], opt = this._transport.mergeOptions(options);
        return stackIntercept<BlocksAtHeightRequest, BlocksAtHeightResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Get information about tokenomics at the end of a given block.
     *
     * @generated from protobuf rpc: GetTokenomicsInfo(concordium.v2.BlockHashInput) returns (concordium.v2.TokenomicsInfo);
     */
    getTokenomicsInfo(input: BlockHashInput, options?: RpcOptions): UnaryCall<BlockHashInput, TokenomicsInfo> {
        const method = this.methods[20], opt = this._transport.mergeOptions(options);
        return stackIntercept<BlockHashInput, TokenomicsInfo>("unary", this._transport, method, opt, input);
    }
    /**
     * Run the smart contract entrypoint in a given context and in the state at
     * the end of the given block.
     *
     * @generated from protobuf rpc: InvokeInstance(concordium.v2.InvokeInstanceRequest) returns (concordium.v2.InvokeInstanceResponse);
     */
    invokeInstance(input: InvokeInstanceRequest, options?: RpcOptions): UnaryCall<InvokeInstanceRequest, InvokeInstanceResponse> {
        const method = this.methods[21], opt = this._transport.mergeOptions(options);
        return stackIntercept<InvokeInstanceRequest, InvokeInstanceResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Get the registered delegators of a given pool at the end of a given block.
     * In contrast to the `GetPoolDelegatorsRewardPeriod` which returns delegators
     * that are fixed for the reward period of the block, this endpoint returns the
     * list of delegators that are registered in the block. Any changes to delegators
     * are immediately visible in this list.
     * The stream will end when all the delegators has been returned.
     *
     * @generated from protobuf rpc: GetPoolDelegators(concordium.v2.GetPoolDelegatorsRequest) returns (stream concordium.v2.DelegatorInfo);
     */
    getPoolDelegators(input: GetPoolDelegatorsRequest, options?: RpcOptions): ServerStreamingCall<GetPoolDelegatorsRequest, DelegatorInfo> {
        const method = this.methods[22], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetPoolDelegatorsRequest, DelegatorInfo>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get the fixed delegators of a given pool for the reward period of the given block.
     * In contracts to the `GetPoolDelegators` which returns delegators registered
     * for the given block, this endpoint returns the fixed delegators contributing
     * stake in the reward period containing the given block.
     * The stream will end when all the delegators has been returned.
     *
     * @generated from protobuf rpc: GetPoolDelegatorsRewardPeriod(concordium.v2.GetPoolDelegatorsRequest) returns (stream concordium.v2.DelegatorRewardPeriodInfo);
     */
    getPoolDelegatorsRewardPeriod(input: GetPoolDelegatorsRequest, options?: RpcOptions): ServerStreamingCall<GetPoolDelegatorsRequest, DelegatorRewardPeriodInfo> {
        const method = this.methods[23], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetPoolDelegatorsRequest, DelegatorRewardPeriodInfo>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get the registered passive delegators at the end of a given block.
     * In contrast to the `GetPassiveDelegatorsRewardPeriod` which returns delegators
     * that are fixed for the reward period of the block, this endpoint returns the
     * list of delegators that are registered in the block. Any changes to delegators
     * are immediately visible in this list.
     * The stream will end when all the delegators has been returned.
     *
     * @generated from protobuf rpc: GetPassiveDelegators(concordium.v2.BlockHashInput) returns (stream concordium.v2.DelegatorInfo);
     */
    getPassiveDelegators(input: BlockHashInput, options?: RpcOptions): ServerStreamingCall<BlockHashInput, DelegatorInfo> {
        const method = this.methods[24], opt = this._transport.mergeOptions(options);
        return stackIntercept<BlockHashInput, DelegatorInfo>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get the fixed passive delegators for the reward period of the given block.
     * In contracts to the `GetPassiveDelegators` which returns delegators registered
     * for the given block, this endpoint returns the fixed delegators contributing
     * stake in the reward period containing the given block.
     * The stream will end when all the delegators has been returned.
     *
     * @generated from protobuf rpc: GetPassiveDelegatorsRewardPeriod(concordium.v2.BlockHashInput) returns (stream concordium.v2.DelegatorRewardPeriodInfo);
     */
    getPassiveDelegatorsRewardPeriod(input: BlockHashInput, options?: RpcOptions): ServerStreamingCall<BlockHashInput, DelegatorRewardPeriodInfo> {
        const method = this.methods[25], opt = this._transport.mergeOptions(options);
        return stackIntercept<BlockHashInput, DelegatorRewardPeriodInfo>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get the current branches of blocks starting from and including the last finalized block.
     *
     * @generated from protobuf rpc: GetBranches(concordium.v2.Empty) returns (concordium.v2.Branch);
     */
    getBranches(input: Empty, options?: RpcOptions): UnaryCall<Empty, Branch> {
        const method = this.methods[26], opt = this._transport.mergeOptions(options);
        return stackIntercept<Empty, Branch>("unary", this._transport, method, opt, input);
    }
    /**
     * Get information related to the baker election for a particular block.
     *
     * @generated from protobuf rpc: GetElectionInfo(concordium.v2.BlockHashInput) returns (concordium.v2.ElectionInfo);
     */
    getElectionInfo(input: BlockHashInput, options?: RpcOptions): UnaryCall<BlockHashInput, ElectionInfo> {
        const method = this.methods[27], opt = this._transport.mergeOptions(options);
        return stackIntercept<BlockHashInput, ElectionInfo>("unary", this._transport, method, opt, input);
    }
    /**
     * Get the identity providers registered as of the end of a given block.
     * The stream will end when all the identity providers have been returned.
     *
     * @generated from protobuf rpc: GetIdentityProviders(concordium.v2.BlockHashInput) returns (stream concordium.v2.IpInfo);
     */
    getIdentityProviders(input: BlockHashInput, options?: RpcOptions): ServerStreamingCall<BlockHashInput, IpInfo> {
        const method = this.methods[28], opt = this._transport.mergeOptions(options);
        return stackIntercept<BlockHashInput, IpInfo>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get the anonymity revokers registered as of the end of a given block.
     * The stream will end when all the anonymity revokers have been returned.
     *
     * @generated from protobuf rpc: GetAnonymityRevokers(concordium.v2.BlockHashInput) returns (stream concordium.v2.ArInfo);
     */
    getAnonymityRevokers(input: BlockHashInput, options?: RpcOptions): ServerStreamingCall<BlockHashInput, ArInfo> {
        const method = this.methods[29], opt = this._transport.mergeOptions(options);
        return stackIntercept<BlockHashInput, ArInfo>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get a list of non-finalized transaction hashes for a given account. This
     * endpoint is not expected to return a large amount of data in most cases,
     * but in bad network condtions it might. The stream will end when all the
     * non-finalized transaction hashes have been returned.
     *
     * @generated from protobuf rpc: GetAccountNonFinalizedTransactions(concordium.v2.AccountAddress) returns (stream concordium.v2.TransactionHash);
     */
    getAccountNonFinalizedTransactions(input: AccountAddress, options?: RpcOptions): ServerStreamingCall<AccountAddress, TransactionHash> {
        const method = this.methods[30], opt = this._transport.mergeOptions(options);
        return stackIntercept<AccountAddress, TransactionHash>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get a list of transaction events in a given block.
     * The stream will end when all the transaction events for a given block have been returned.
     *
     * @generated from protobuf rpc: GetBlockTransactionEvents(concordium.v2.BlockHashInput) returns (stream concordium.v2.BlockItemSummary);
     */
    getBlockTransactionEvents(input: BlockHashInput, options?: RpcOptions): ServerStreamingCall<BlockHashInput, BlockItemSummary> {
        const method = this.methods[31], opt = this._transport.mergeOptions(options);
        return stackIntercept<BlockHashInput, BlockItemSummary>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get a list of special events in a given block. These are events generated
     * by the protocol, such as minting and reward payouts. They are not directly
     * generated by any transaction. The stream will end when all the special
     * events for a given block have been returned.
     *
     * @generated from protobuf rpc: GetBlockSpecialEvents(concordium.v2.BlockHashInput) returns (stream concordium.v2.BlockSpecialEvent);
     */
    getBlockSpecialEvents(input: BlockHashInput, options?: RpcOptions): ServerStreamingCall<BlockHashInput, BlockSpecialEvent> {
        const method = this.methods[32], opt = this._transport.mergeOptions(options);
        return stackIntercept<BlockHashInput, BlockSpecialEvent>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get the pending updates to chain parameters at the end of a given block.
     * The stream will end when all the pending updates for a given block have been returned.
     *
     * @generated from protobuf rpc: GetBlockPendingUpdates(concordium.v2.BlockHashInput) returns (stream concordium.v2.PendingUpdate);
     */
    getBlockPendingUpdates(input: BlockHashInput, options?: RpcOptions): ServerStreamingCall<BlockHashInput, PendingUpdate> {
        const method = this.methods[33], opt = this._transport.mergeOptions(options);
        return stackIntercept<BlockHashInput, PendingUpdate>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get next available sequence numbers for updating chain parameters after a given block.
     *
     * @generated from protobuf rpc: GetNextUpdateSequenceNumbers(concordium.v2.BlockHashInput) returns (concordium.v2.NextUpdateSequenceNumbers);
     */
    getNextUpdateSequenceNumbers(input: BlockHashInput, options?: RpcOptions): UnaryCall<BlockHashInput, NextUpdateSequenceNumbers> {
        const method = this.methods[34], opt = this._transport.mergeOptions(options);
        return stackIntercept<BlockHashInput, NextUpdateSequenceNumbers>("unary", this._transport, method, opt, input);
    }
    /**
     * Get the projected earliest time at which a particular baker will be required to bake a block.
     * If the current consensus version is 0, this returns the status 'Unavailable', as the endpoint
     * is only supported by consensus version 1.
     *
     * If the baker is not a baker for the current reward period, this returns a timestamp at the
     * start of the next reward period. If the baker is a baker for the current reward period, the
     * earliest win time is projected from the current round forward, assuming that each round after
     * the last finalized round will take the minimum block time. (If blocks take longer, or timeouts
     * occur, the actual time may be later, and the reported time in subsequent queries may reflect
     * this.) At the end of an epoch (or if the baker is not projected to bake before the end of the
     * epoch) the earliest win time for a (current) baker will be projected as the start of the next
     * epoch. This is because the seed for the leader election is updated at the epoch boundary, and
     * so the winners cannot be predicted beyond that. Note that in some circumstances the returned
     * timestamp can be in the past, especially at the end of an epoch.
     *
     * @generated from protobuf rpc: GetBakerEarliestWinTime(concordium.v2.BakerId) returns (concordium.v2.Timestamp);
     */
    getBakerEarliestWinTime(input: BakerId, options?: RpcOptions): UnaryCall<BakerId, Timestamp> {
        const method = this.methods[35], opt = this._transport.mergeOptions(options);
        return stackIntercept<BakerId, Timestamp>("unary", this._transport, method, opt, input);
    }
    /**
     * Shut down the node.
     * Return a GRPC error if the shutdown failed.
     *
     * @generated from protobuf rpc: Shutdown(concordium.v2.Empty) returns (concordium.v2.Empty);
     */
    shutdown(input: Empty, options?: RpcOptions): UnaryCall<Empty, Empty> {
        const method = this.methods[36], opt = this._transport.mergeOptions(options);
        return stackIntercept<Empty, Empty>("unary", this._transport, method, opt, input);
    }
    /**
     * Suggest to a peer to connect to the submitted peer details.
     * This, if successful, adds the peer to the list of given addresses.
     * Otherwise return a GRPC error.
     * Note. The peer might not be connected to instantly, in that case
     * the node will try to establish the connection in near future. This
     * function returns a GRPC status 'Ok' in this case.
     *
     * @generated from protobuf rpc: PeerConnect(concordium.v2.IpSocketAddress) returns (concordium.v2.Empty);
     */
    peerConnect(input: IpSocketAddress, options?: RpcOptions): UnaryCall<IpSocketAddress, Empty> {
        const method = this.methods[37], opt = this._transport.mergeOptions(options);
        return stackIntercept<IpSocketAddress, Empty>("unary", this._transport, method, opt, input);
    }
    /**
     * Disconnect from the peer and remove them from the given addresses list
     * if they are on it. Return if the request was processed successfully.
     * Otherwise return a GRPC error.
     *
     * @generated from protobuf rpc: PeerDisconnect(concordium.v2.IpSocketAddress) returns (concordium.v2.Empty);
     */
    peerDisconnect(input: IpSocketAddress, options?: RpcOptions): UnaryCall<IpSocketAddress, Empty> {
        const method = this.methods[38], opt = this._transport.mergeOptions(options);
        return stackIntercept<IpSocketAddress, Empty>("unary", this._transport, method, opt, input);
    }
    /**
     * Get a list of banned peers.
     *
     * @generated from protobuf rpc: GetBannedPeers(concordium.v2.Empty) returns (concordium.v2.BannedPeers);
     */
    getBannedPeers(input: Empty, options?: RpcOptions): UnaryCall<Empty, BannedPeers> {
        const method = this.methods[39], opt = this._transport.mergeOptions(options);
        return stackIntercept<Empty, BannedPeers>("unary", this._transport, method, opt, input);
    }
    /**
     * Ban the given peer.
     * Returns a GRPC error if the action failed.
     *
     * @generated from protobuf rpc: BanPeer(concordium.v2.PeerToBan) returns (concordium.v2.Empty);
     */
    banPeer(input: PeerToBan, options?: RpcOptions): UnaryCall<PeerToBan, Empty> {
        const method = this.methods[40], opt = this._transport.mergeOptions(options);
        return stackIntercept<PeerToBan, Empty>("unary", this._transport, method, opt, input);
    }
    /**
     * Unban the banned peer.
     * Returns a GRPC error if the action failed.
     *
     * @generated from protobuf rpc: UnbanPeer(concordium.v2.BannedPeer) returns (concordium.v2.Empty);
     */
    unbanPeer(input: BannedPeer, options?: RpcOptions): UnaryCall<BannedPeer, Empty> {
        const method = this.methods[41], opt = this._transport.mergeOptions(options);
        return stackIntercept<BannedPeer, Empty>("unary", this._transport, method, opt, input);
    }
    /**
     * Start dumping packages into the specified file.
     * Only enabled if the node was built with the `network_dump` feature.
     * Returns a GRPC error if the network dump failed to start.
     *
     * @generated from protobuf rpc: DumpStart(concordium.v2.DumpRequest) returns (concordium.v2.Empty);
     */
    dumpStart(input: DumpRequest, options?: RpcOptions): UnaryCall<DumpRequest, Empty> {
        const method = this.methods[42], opt = this._transport.mergeOptions(options);
        return stackIntercept<DumpRequest, Empty>("unary", this._transport, method, opt, input);
    }
    /**
     * Stop dumping packages.
     * Only enabled if the node was built with the `network_dump` feature.
     * Returns a GRPC error if the network dump failed to be stopped.
     *
     * @generated from protobuf rpc: DumpStop(concordium.v2.Empty) returns (concordium.v2.Empty);
     */
    dumpStop(input: Empty, options?: RpcOptions): UnaryCall<Empty, Empty> {
        const method = this.methods[43], opt = this._transport.mergeOptions(options);
        return stackIntercept<Empty, Empty>("unary", this._transport, method, opt, input);
    }
    /**
     * / Get a list of the peers that the node is connected to
     * / and assoicated network related information for each peer.
     *
     * @generated from protobuf rpc: GetPeersInfo(concordium.v2.Empty) returns (concordium.v2.PeersInfo);
     */
    getPeersInfo(input: Empty, options?: RpcOptions): UnaryCall<Empty, PeersInfo> {
        const method = this.methods[44], opt = this._transport.mergeOptions(options);
        return stackIntercept<Empty, PeersInfo>("unary", this._transport, method, opt, input);
    }
    /**
     * Get information about the node.
     * The `NodeInfo` includes information of
     * * Meta information such as the, version of the node, type of the node, uptime and the local time of the node.
     * * NetworkInfo which yields data such as the node id, packets sent/received,
     *   average bytes per second sent/received.
     * * ConsensusInfo. The `ConsensusInfo` returned depends on if the node supports
     *   the protocol on chain and whether the node is configured as a baker or not.
     *
     * @generated from protobuf rpc: GetNodeInfo(concordium.v2.Empty) returns (concordium.v2.NodeInfo);
     */
    getNodeInfo(input: Empty, options?: RpcOptions): UnaryCall<Empty, NodeInfo> {
        const method = this.methods[45], opt = this._transport.mergeOptions(options);
        return stackIntercept<Empty, NodeInfo>("unary", this._transport, method, opt, input);
    }
    /**
     * Send a block item. A block item is either an `AccountTransaction`, which is
     * a transaction signed and paid for by an account, a `CredentialDeployment`,
     * which creates a new account, or `UpdateInstruction`, which is an
     * instruction to change some parameters of the chain. Update instructions can
     * only be sent by the governance committee.
     *
     * Returns a hash of the block item, which can be used with
     * `GetBlockItemStatus`.
     *
     * @generated from protobuf rpc: SendBlockItem(concordium.v2.SendBlockItemRequest) returns (concordium.v2.TransactionHash);
     */
    sendBlockItem(input: SendBlockItemRequest, options?: RpcOptions): UnaryCall<SendBlockItemRequest, TransactionHash> {
        const method = this.methods[46], opt = this._transport.mergeOptions(options);
        return stackIntercept<SendBlockItemRequest, TransactionHash>("unary", this._transport, method, opt, input);
    }
    /**
     * Get the hash to be signed for an account transaction. The hash returned
     * should be signed and the signatures included as an
     * AccountTransactionSignature when calling `SendBlockItem`. This is provided as
     * a convenience to support cases where the right SDK is not available for
     * interacting with the node. If an SDK is available then it is strongly
     * recommended to compute this hash off-line using it. That reduces the trust
     * in the node, removes networking failure modes, and will perform better.
     *
     * @generated from protobuf rpc: GetAccountTransactionSignHash(concordium.v2.PreAccountTransaction) returns (concordium.v2.AccountTransactionSignHash);
     */
    getAccountTransactionSignHash(input: PreAccountTransaction, options?: RpcOptions): UnaryCall<PreAccountTransaction, AccountTransactionSignHash> {
        const method = this.methods[47], opt = this._transport.mergeOptions(options);
        return stackIntercept<PreAccountTransaction, AccountTransactionSignHash>("unary", this._transport, method, opt, input);
    }
    /**
     * Get the values of chain parameters in effect in the given block.
     *
     * @generated from protobuf rpc: GetBlockChainParameters(concordium.v2.BlockHashInput) returns (concordium.v2.ChainParameters);
     */
    getBlockChainParameters(input: BlockHashInput, options?: RpcOptions): UnaryCall<BlockHashInput, ChainParameters> {
        const method = this.methods[48], opt = this._transport.mergeOptions(options);
        return stackIntercept<BlockHashInput, ChainParameters>("unary", this._transport, method, opt, input);
    }
    /**
     * Get the summary of the finalization data in a given block.
     *
     * @generated from protobuf rpc: GetBlockFinalizationSummary(concordium.v2.BlockHashInput) returns (concordium.v2.BlockFinalizationSummary);
     */
    getBlockFinalizationSummary(input: BlockHashInput, options?: RpcOptions): UnaryCall<BlockHashInput, BlockFinalizationSummary> {
        const method = this.methods[49], opt = this._transport.mergeOptions(options);
        return stackIntercept<BlockHashInput, BlockFinalizationSummary>("unary", this._transport, method, opt, input);
    }
    /**
     * Get the items of a block.
     *
     * @generated from protobuf rpc: GetBlockItems(concordium.v2.BlockHashInput) returns (stream concordium.v2.BlockItem);
     */
    getBlockItems(input: BlockHashInput, options?: RpcOptions): ServerStreamingCall<BlockHashInput, BlockItem> {
        const method = this.methods[50], opt = this._transport.mergeOptions(options);
        return stackIntercept<BlockHashInput, BlockItem>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get all bakers in the reward period of a block.
     * This endpoint is only supported for protocol version 6 and onwards.
     * If the protocol does not support the endpoint then an  'IllegalArgument' error is returned.
     *
     * @generated from protobuf rpc: GetBakersRewardPeriod(concordium.v2.BlockHashInput) returns (stream concordium.v2.BakerRewardPeriodInfo);
     */
    getBakersRewardPeriod(input: BlockHashInput, options?: RpcOptions): ServerStreamingCall<BlockHashInput, BakerRewardPeriodInfo> {
        const method = this.methods[51], opt = this._transport.mergeOptions(options);
        return stackIntercept<BlockHashInput, BakerRewardPeriodInfo>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * For a non-genesis block, this returns the quorum certificate, a timeout
     * certificate (if present) and epoch finalization entry (if present).
     * Note that, if the block being pointed to is not a product of ConcordiumBFT,
     * then the response will be a grpc error (invalid argument).
     * If the endpoint is not enabled by the node, then an 'unimplemented' error
     * will be returned.
     *
     * @generated from protobuf rpc: GetBlockCertificates(concordium.v2.BlockHashInput) returns (concordium.v2.BlockCertificates);
     */
    getBlockCertificates(input: BlockHashInput, options?: RpcOptions): UnaryCall<BlockHashInput, BlockCertificates> {
        const method = this.methods[52], opt = this._transport.mergeOptions(options);
        return stackIntercept<BlockHashInput, BlockCertificates>("unary", this._transport, method, opt, input);
    }
    /**
     * Get the list of bakers that won the lottery in a particular historical epoch (i.e. the
     * last finalized block is in a later epoch). This lists the winners for each round in the
     * epoch, starting from the round after the last block in the previous epoch, running to
     * the round before the first block in the next epoch. It also indicates if a block in each
     * round was included in the finalized chain.
     *
     * The following error cases are possible:
     *  * `NOT_FOUND` if the query specifies an unknown block.
     *  * `UNAVAILABLE` if the query is for an epoch that is not finalized in the current genesis
     * /    index, or is for a future genesis index.
     *  * `INVALID_ARGUMENT` if the query is for an epoch that is not finalized for a past genesis
     *    index.
     *  * `INVALID_ARGUMENT` if the query is for a genesis index at consensus version 0.
     *  * `INVALID_ARGUMENT` if the input `EpochRequest` is malformed.
     *  * `UNIMPLEMENTED` if the endpoint is disabled on the node.
     *
     * @generated from protobuf rpc: GetWinningBakersEpoch(concordium.v2.EpochRequest) returns (stream concordium.v2.WinningBaker);
     */
    getWinningBakersEpoch(input: EpochRequest, options?: RpcOptions): ServerStreamingCall<EpochRequest, WinningBaker> {
        const method = this.methods[53], opt = this._transport.mergeOptions(options);
        return stackIntercept<EpochRequest, WinningBaker>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get the block hash of the first finalized block in a specified epoch.
     *
     * The following error cases are possible:
     *  * `NOT_FOUND` if the query specifies an unknown block.
     *  * `UNAVAILABLE` if the query is for an epoch that is not finalized in the current genesis
     *    index, or is for a future genesis index.
     *  * `INVALID_ARGUMENT` if the query is for an epoch with no finalized blocks for a past genesis
     *    index.
     *  * `INVALID_ARGUMENT` if the input `EpochRequest` is malformed.
     *  * `UNIMPLEMENTED` if the endpoint is disabled on the node.
     *
     * @generated from protobuf rpc: GetFirstBlockEpoch(concordium.v2.EpochRequest) returns (concordium.v2.BlockHash);
     */
    getFirstBlockEpoch(input: EpochRequest, options?: RpcOptions): UnaryCall<EpochRequest, BlockHash> {
        const method = this.methods[54], opt = this._transport.mergeOptions(options);
        return stackIntercept<EpochRequest, BlockHash>("unary", this._transport, method, opt, input);
    }
    /**
     * Dry run a series of transactions and operations on a state derived from a specified block.
     * The server should send a single `DryRunResponse` for each `DryRunRequest` received, unless
     * the call fails with an error status code. If a request produces a `DryRunErrorResponse`, then
     * the server will still process subsequent requests, just as if the request causing the error
     * did not happen.
     *
     * The first request should be `load_block_at_state` to determine the block state that will be
     * used for the dry run.
     *
     * The server associates each request with an energy cost, and limits the total energy that may
     * be expended in a single invocation of `DryRun`. This limit is reported as `quota` in the
     * initial metadata returned by the server. If executing an operation exceeds the limit,
     * the server terminates the session with `RESOURCE_EXHAUSTED`.
     *
     * The server also imposes a timeout for a dry-run session to complete. The server reports
     * the timeout duration in milliseconds in the initial metadata field `timeout`. If the session
     * is not completed before the timeout elapses, the server terminates the session with
     * `DEADLINE_EXCEEDED`.
     *
     * The following error cases are possible:
     *  * `INVALID_ARGUMENT` if any `DryRunRequest` is malformed.
     *  * `RESOURCE_EXHAUSTED` if the energy quota is exceeded.
     *  * `DEADLINE_EXCEEDED` if the session does not complete before the server-imposed timeout.
     *  * `RESOURCE_EXHAUSTED` if the server is not currently accepting new `DryRun` sessions.
     *    (The server may impose a limit on the number of concurrent sessions.)
     *  * `INTERNAL` if an interal server error occurs. This should not happen, and likely indicates
     *    a bug.
     *  * `UNIMPLEMENTED` if the endpoint is disabled on the node.
     *
     * @generated from protobuf rpc: DryRun(stream concordium.v2.DryRunRequest) returns (stream concordium.v2.DryRunResponse);
     */
    dryRun(options?: RpcOptions): DuplexStreamingCall<DryRunRequest, DryRunResponse> {
        const method = this.methods[55], opt = this._transport.mergeOptions(options);
        return stackIntercept<DryRunRequest, DryRunResponse>("duplex", this._transport, method, opt);
    }
}
