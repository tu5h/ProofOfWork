// @generated by protobuf-ts 2.9.1 with parameter optimize_code_size
// @generated from protobuf file "v2/concordium/health.proto" (package "concordium.health", syntax proto3)
// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { Health } from "./health.js";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { NodeHealthResponse } from "./health.js";
import type { NodeHealthRequest } from "./health.js";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * @generated from protobuf service concordium.health.Health
 */
export interface IHealthClient {
    /**
     * Check the health of the node. By necessity this involves a number of
     * heuristics since in a distributed network we have to rely on the local
     * information only and we don't have authoritative data on, e.g., last
     * finalized block.
     *
     * In particular, a node that is not caught up to the head of the chain is not
     * healthy.
     *
     * If possible the client should use other queries to get a more fine-grained
     * understanding of the node health. However this endpoint should provide a
     * reasonable default and is usable in cases where an automatic check is
     * performed that does not allow for configuration, such as in load-balancers.
     *
     * @generated from protobuf rpc: Check(concordium.health.NodeHealthRequest) returns (concordium.health.NodeHealthResponse);
     */
    check(input: NodeHealthRequest, options?: RpcOptions): UnaryCall<NodeHealthRequest, NodeHealthResponse>;
}
/**
 * @generated from protobuf service concordium.health.Health
 */
export class HealthClient implements IHealthClient, ServiceInfo {
    typeName = Health.typeName;
    methods = Health.methods;
    options = Health.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * Check the health of the node. By necessity this involves a number of
     * heuristics since in a distributed network we have to rely on the local
     * information only and we don't have authoritative data on, e.g., last
     * finalized block.
     *
     * In particular, a node that is not caught up to the head of the chain is not
     * healthy.
     *
     * If possible the client should use other queries to get a more fine-grained
     * understanding of the node health. However this endpoint should provide a
     * reasonable default and is usable in cases where an automatic check is
     * performed that does not allow for configuration, such as in load-balancers.
     *
     * @generated from protobuf rpc: Check(concordium.health.NodeHealthRequest) returns (concordium.health.NodeHealthResponse);
     */
    check(input: NodeHealthRequest, options?: RpcOptions): UnaryCall<NodeHealthRequest, NodeHealthResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<NodeHealthRequest, NodeHealthResponse>("unary", this._transport, method, opt, input);
    }
}
