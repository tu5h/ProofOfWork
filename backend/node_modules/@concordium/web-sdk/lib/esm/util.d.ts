import { Buffer } from 'buffer/index.js';
import { AccountTransactionSignature, HexString, IpAddressString } from './types.js';
/**
 * Replaces a string in a JSON string with the same string as a
 * number, i.e. removing quotes (") prior to and after the string. This
 * is needed as the default JSON stringify cannot serialize BigInts as numbers.
 * So one can turn them into strings, stringify the structure, and then use this function
 * to make those fields into JSON numbers.
 * @param jsonStruct the JSON structure as a string
 * @param keys the keys where the strings has to be unquoted
 * @returns the same JSON string where the strings at the supplied keys are unquoted
 */
export declare function stringToInt(jsonStruct: string, keys: string[]): string;
/**
 * Checks if the input string is a valid hexadecimal string.
 * @param str the string to check for hexadecimal
 */
export declare function isHex(str: string): boolean;
/**
 * Checks whether the input string looks to be a valid hash,
 * i.e. it has length 64 and consists of hexadecimal characters.
 * @param hash the string to check
 * @returns false if the string cannot be a valid hash, otherwise true
 */
export declare function isValidHash(hash: HexString): boolean;
export declare function isValidIp(ip: IpAddressString): boolean;
/**
 * Counts the total number of signatures.
 * @param accountSignatures the signature structure to count
 */
export declare function countSignatures(accountSignatures: AccountTransactionSignature): bigint;
/**
 * Compiles a wasm module and extracts the smart contract schema.
 *
 * @param wasm the wasm module as a Buffer
 *
 * @throws If WASM module contains no schema
 * @throws If WASM module provided is invalid
 *
 * @returns the smart contract schema as a Buffer
 */
export declare function wasmToSchema(wasm: ArrayBuffer): Uint8Array;
/**
 * Extracts custom-section containing the smart contract schema if present.
 * @param wasmModule the WebAssembly module.
 * @returns the smart contract schema as a Buffer or null if not present.
 */
export declare function schemaBytesFromWasmModule(wasmModule: WebAssembly.Module, sectionName: 'concordium-schema' | 'concordium-schema-v1' | 'concordium-schema-v2'): ArrayBuffer | null;
/**
 * Convert a Date to seconds since epoch.
 */
export declare function secondsSinceEpoch(date: Date): bigint;
export declare function unwrap<A>(x: A | undefined): A;
export declare function mapRecord<A extends string | number | symbol, B, C extends string | number | symbol, D>(rec: Record<A, B>, valMapper: (x: B) => D, keyMapper?: (x: A) => C): Record<C, D>;
/**
 * Maps an infinite stream of type A to an infinite stream of type B
 * @param mapper: function used to map each element from type A to B.
 */
export declare function mapStream<A, B>(stream: AsyncIterable<A>, mapper: (x: A) => B): AsyncIterable<B>;
/**
 * Filters entries from a record
 * @param rec the record, whose entries should be filtered.
 * @param predicate predicate to test entries, only if this returns true does the entry remain
 */
export declare function filterRecord<A extends string | number | symbol, B>(rec: Record<A, B>, predicate: (k: A, v: B) => boolean): Record<A, B>;
export declare function streamToList<A>(iterable: AsyncIterable<A>): Promise<A[]>;
/**
 * Creates a function that takes either a `T` or `T[]` from a function that takes `T[]`.
 *
 * @param {(input: T[]) => R} fun - A function that takes `T[]`
 *
 * @example
 * const serializer = makeDynamicFunction(serialize);
 * const exampleStruct = {
    tokenId: '';
    tokenAmount: 100n;
    from: {
address: "3nsRkrtQVMRtD2Wvm88gEDi6UtqdUVvRN3oGZ1RqNJ3eto8owi"
};
    to: 3nsRkrtQVMRtD2Wvm88gEDi6UtqdUVvRN3oGZ1RqNJ3eto8owi;
    data: '48656c6c6f20776f726c6421';
};
 * const bytesSingle = serializer(exampleStruct);
 * const bytesMulti = serializer([exampleStruct, exampleStruct]);
 */
export declare const makeDynamicFunction: <T, R>(fun: (a: T[]) => R) => (input: T | T[]) => R;
export declare function isDefined<T>(v?: T): v is T;
export declare function toBuffer(s: string, encoding?: string): Buffer;
/**
 * Immediately returns an {@linkcode Error} with the message passed. This allows use of throwing errors as expressions.
 * @param message - The message to pass to the error
 * @throws an error immediately
 *
 * @example
 * const value = maybeValue ?? bail('Turns out there was not value anyway...');
 */
export declare const bail: (message: string) => never;
