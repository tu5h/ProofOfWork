import { Buffer } from 'buffer/index.js';
import { stringify } from 'json-bigint';
import { signTransaction } from './signHelpers.js';
import { AccountTransactionType, } from './types.js';
import * as AccountAddress from './types/AccountAddress.js';
import * as CcdAmount from './types/CcdAmount.js';
import * as ContractAddress from './types/ContractAddress.js';
import * as ContractName from './types/ContractName.js';
import * as EntrypointName from './types/EntrypointName.js';
import * as Parameter from './types/Parameter.js';
import * as ReceiveName from './types/ReceiveName.js';
import * as ReturnValue from './types/ReturnValue.js';
import * as TransactionExpiry from './types/TransactionExpiry.js';
/**
 * Default expiry date used for contract update transactions.
 */
export function getContractUpdateDefaultExpiryDate() {
    return TransactionExpiry.futureMinutes(5);
}
/**
 * Defines methods for performing dry-run invocations of updates on a Contract with entrypoints `E`
 *
 * @template E - union of entrypoints
 */
export class ContractDryRun {
    constructor(grpcClient, contractAddress, contractName) {
        this.grpcClient = grpcClient;
        this.contractAddress = contractAddress;
        this.contractName = contractName;
    }
    /**
     * Performs a dry-run of a contract entrypoint invocation.
     * Useful for getting an indication of the result of an invocation of the entrypoint (e.g. getting a cost estimate).
     *
     * @template T - The type of the input given
     *
     * @param {EntrypointName.Type} entrypoint - The name of the receive function to invoke.
     * @param {ContractInvokeMetadata | ContractAddress | AccountAddress.Type} metaOrInvoker - Metadata for contract invocation of the address of the invoker.
     * @param {Function} serializer - A function for serializing the input to bytes.
     * @param {T} input - Input for for contract function.
     * @param {BlockHash.Type} [blockHash] - The hash of the block to perform the invocation of. Defaults to the latest finalized block on chain.
     *
     * @returns {InvokeContractResult} the contract invocation result, which includes whether or not the invocation succeeded along with the energy spent.
     */
    invokeMethod(entrypoint, metaOrInvoker, serializer, input, blockHash) {
        const parameter = Parameter.fromBuffer(serializer(input));
        const meta = AccountAddress.instanceOf(metaOrInvoker) || ContractAddress.instanceOf(metaOrInvoker)
            ? { invoker: metaOrInvoker }
            : metaOrInvoker;
        return this.grpcClient.invokeContract({
            ...meta,
            contract: this.contractAddress,
            parameter,
            method: ReceiveName.create(this.contractName, entrypoint),
        }, blockHash);
    }
}
/**
 * Base class for interacting with arbitrary contracts. Public version is {@link Contract}.
 *
 * @template E - union of update entrypoints
 * @template V - union of view entrypoints
 */
class ContractBase {
    constructor(grpcClient, contractAddress, contractName, schema) {
        this.grpcClient = grpcClient;
        this.contractAddress = contractAddress;
        this.contractName = contractName;
        this.schema = schema;
        this.dryRunInstance = new ContractDryRun(grpcClient, contractAddress, contractName);
    }
    /**
     * Helper function for getting the {@link InstanceInfo} of a contract
     *
     * @param {ConcordiumGRPCClient} grpcClient - The GRPC client for accessing a node.
     * @param {ContractAddress.Type} contractAddress - The address of the contract.
     *
     * @throws if the {@link InstanceInfo} of the contract could not be found.
     *
     * @returns {InstanceInfo} the instance info.
     */
    static async getInstanceInfo(grpcClient, contractAddress) {
        try {
            return await grpcClient.getInstanceInfo(contractAddress);
        }
        catch (e) {
            throw new Error(`Could not get contract instance info for contract at address ${ContractAddress.toString(contractAddress)}: ${e.message ?? e}`);
        }
    }
    /**
     * Helper function for getting the name of a contract
     *
     * @param {ConcordiumGRPCClient} grpcClient - The GRPC client for accessing a node.
     * @param {ContractAddress.Type} contractAddress - The address of the contract.
     *
     * @throws if the {@link InstanceInfo} of the contract could not be found.
     *
     * @returns {ContractName.Type} the name of the contract.
     */
    static async getContractName(grpcClient, contractAddress) {
        const instanceInfo = await this.getInstanceInfo(grpcClient, contractAddress);
        return ContractName.fromInitName(instanceInfo.name);
    }
    /**
     * Get information on this smart contract instance.
     *
     * @param {BlockHash.Type} [blockHash] Hash of the block to check information at. When not provided the last finalized block is used.

     * @throws if the {@link InstanceInfo} of the contract could not be found.

     * @returns {InstanceInfo} The instance info.
     */
    async getInstanceInfo(blockHash) {
        return this.grpcClient.getInstanceInfo(this.contractAddress, blockHash);
    }
    /**
     * Check if the smart contract instance exists on the blockchain and whether it uses a matching contract name.
     * Optionally a module reference can be provided to check if the contract instance uses this module.
     *
     * @param {ContractCheckOnChainOptions} [options] Options for checking information on chain.
     *
     * @throws {RpcError} If failing to communicate with the concordium node or if the instance does not exist on chain or fails the checks.
     */
    async checkOnChain(options = {}) {
        const info = await this.getInstanceInfo(options.blockHash);
        const contractNameOnChain = ContractName.fromInitName(info.name);
        if (!ContractName.equals(contractNameOnChain, this.contractName)) {
            throw new Error(`Instance ${ContractAddress.toString(this.contractAddress)} has contract name '${contractNameOnChain.value}' on chain. The client expected: '${this.contractName.value}'.`);
        }
        if (options.moduleReference !== undefined &&
            info.sourceModule.moduleRef !== options.moduleReference.moduleRef) {
            throw new Error(`Instance ${ContractAddress.toString(this.contractAddress)} uses module with reference '${info.sourceModule.moduleRef}' expected '${options.moduleReference.moduleRef}'`);
        }
    }
    /**
     * A dry-run instance, providing access to methods for performing dry-run invocations of update instructions.
     */
    get dryRun() {
        return this.dryRunInstance;
    }
    createUpdateTransaction(entrypoint, serializeInput, { amount = CcdAmount.zero(), energy }, input, inputJsonFormatter) {
        const parameter = Parameter.fromBuffer(serializeInput(input));
        const payload = {
            amount,
            address: this.contractAddress,
            receiveName: ReceiveName.create(this.contractName, entrypoint),
            maxContractExecutionEnergy: energy,
            message: parameter,
        };
        const transaction = {
            type: AccountTransactionType.Update,
            payload,
        };
        if (inputJsonFormatter === undefined) {
            return transaction;
        }
        const jsonParameter = inputJsonFormatter(input);
        let schema;
        if (typeof this.schema === 'string') {
            schema = {
                value: this.schema,
                type: 'module',
            };
        }
        else if (this.schema?.[EntrypointName.toString(entrypoint)] !== undefined) {
            schema = {
                value: this.schema[EntrypointName.toString(entrypoint)],
                type: 'parameter',
            };
        }
        return {
            ...transaction,
            parameter: {
                hex: Parameter.toHexString(parameter),
                json: jsonParameter,
            },
            schema,
        };
    }
    /**
     * Submits a {@link ContractUpdateTransaction} contract update transaction.
     *
     * @param {ContractUpdateTransaction} transactionBase - The details of the transaction to send.
     * @param {ContractTransactionMetadata} metadata - Metadata to be used for the transaction (with defaults).
     * @param {AccountSigner} signer - An object to use for signing the transaction.
     *
     * @throws If the query could not be invoked successfully.
     *
     * @returns {TransactionHash.Type} The transaction hash of the update transaction
     */
    async sendUpdateTransaction(transactionBase, { senderAddress, expiry = getContractUpdateDefaultExpiryDate() }, signer) {
        const { nonce } = await this.grpcClient.getNextAccountNonce(senderAddress);
        const header = {
            expiry,
            nonce: nonce,
            sender: senderAddress,
        };
        const transaction = {
            ...transactionBase,
            header,
        };
        const signature = await signTransaction(transaction, signer);
        return this.grpcClient.sendAccountTransaction(transaction, signature);
    }
    /**
     * Creates and sends a contract update transaction with parameter `input` to `entrypoint`.
     *
     * @template T - The type of the input
     *
     * @param {EntrypointName.Type} entrypoint - The name of the receive function to invoke.
     * @param {Function} serializeInput - A function to serialize the `input` to bytes.
     * @param {CIS2.TransactionMetadata} metadata - Metadata to be used for the transaction (with defaults).
     * @param {T} input - Input for for contract function.
     * @param {AccountSigner} signer - An object to use for signing the transaction.
     *
     * @throws If the query could not be invoked successfully.
     *
     * @returns {TransactionHash.Type} The transaction hash of the update transaction
     */
    async createAndSendUpdateTransaction(entrypoint, serializeInput, metadata, input, signer) {
        const transactionBase = this.createUpdateTransaction(entrypoint, serializeInput, metadata, input);
        return this.sendUpdateTransaction(transactionBase, metadata, signer);
    }
    /**
     * Invokes `entrypoint` view function on contract.
     *
     * @template T - The type of the input
     * @template R - The type the invocation response should be deserialized into.
     *
     * @param {EntrypointName.Type} entrypoint - The name of the view function to invoke.
     * @param {Function} serializeInput - A function to serialize the `input` to bytes.
     * @param {Function} deserializeResponse - A function to deserialize the value returned from the view invocation.
     * @param {T | T[]} input - Input for for contract function.
     * @param {BlockHash.Type} [blockHash] - The hash of the block to perform the invocation of. Defaults to the latest finalized block on chain.
     *
     * @throws If the query could not be invoked successfully.
     *
     * @returns {R} The transaction hash of the update transaction
     */
    async invokeView(entrypoint, serializeInput, deserializeResponse, input, blockHash) {
        const parameter = Parameter.fromBuffer(serializeInput(input));
        const response = await this.grpcClient.invokeContract({
            contract: this.contractAddress,
            parameter,
            method: ReceiveName.create(this.contractName, entrypoint),
        }, blockHash);
        if (response === undefined || response.tag === 'failure' || response.returnValue === undefined) {
            throw new Error(`Failed to invoke view ${entrypoint} for contract at ${ContractAddress.toString(this.contractAddress)}${response.tag === 'failure' && ` with error ${stringify(response.reason)}`}`);
        }
        return deserializeResponse(ReturnValue.toHexString(response.returnValue));
    }
}
/**
 * Base class for interacting with arbitrary contracts. Public version is {@link Contract}.
 *
 * @template E - union of update entrypoints
 * @template V - union of view entrypoints
 */
export class Contract extends ContractBase {
    /**
     * Creates a new `Contract` instance by querying the node for the necessary information through the supplied `grpcClient`.
     *
     * @param {ConcordiumGRPCClient} grpcClient - The client used for contract invocations and updates.
     * @param {ContractAddress} contractAddress - Address of the contract instance.
     * @param {Schema} [schema] - The schema of the contract, either defined as parameter schemas per entrypoint `E` or as a single module schema.
     * If no schema is defined, an attempt to get an embedded schema from the contract is made.
     *
     * @throws If `InstanceInfo` could not be received for the contract,
     *
     * or if the contract name could not be parsed from the information received from the node.
     */
    static async create(grpcClient, contractAddress, schema) {
        const instanceInfo = await super.getInstanceInfo(grpcClient, contractAddress);
        // No reason to run checks, since this is from chain.
        const contractName = ContractName.fromInitName(instanceInfo.name);
        let mSchema;
        if (!schema) {
            try {
                const raw = await grpcClient.getEmbeddedSchema(instanceInfo.sourceModule);
                const encoded = Buffer.from(raw).toString('base64');
                if (encoded) {
                    mSchema = encoded;
                }
            }
            catch {
                // Do nothing.
            }
        }
        return new Contract(grpcClient, contractAddress, contractName, schema ?? mSchema);
    }
}
/**
 * Abstract class for defining "clients" for enabling users to seemlessly interact with
 * contracts adhering to standards (i.e. CIS contracts)
 *
 * @template E - union of update entrypoints
 * @template V - union of view entrypoints
 * @template D - {@link ContractDryRun} extension
 */
export class CISContract extends ContractBase {
    constructor(grpcClient, contractAddress, contractName) {
        super(grpcClient, contractAddress, contractName);
        this.grpcClient = grpcClient;
        this.contractAddress = contractAddress;
        this.contractName = contractName;
        this.dryRunInstance = this.makeDryRunInstance(grpcClient, contractAddress, contractName);
    }
    /**
     * A dry-run instance, providing access to methods for performing dry-run invocations of update instructions.
     */
    get dryRun() {
        return this.dryRunInstance;
    }
    createUpdateTransaction(entrypoint, serializeInput, metadata, input, inputJsonFormatter) {
        if (inputJsonFormatter === undefined) {
            return super.createUpdateTransaction(entrypoint, serializeInput, metadata, input);
        }
        const transaction = super.createUpdateTransaction(entrypoint, serializeInput, metadata, input, inputJsonFormatter);
        if (transaction.schema === undefined) {
            throw new Error(`Could not find schema for entrypoint ${entrypoint}`);
        }
        return transaction;
    }
}
//# sourceMappingURL=GenericContract.js.map