import { Buffer } from 'buffer/index.js';
import { CISContract, ContractDryRun, getContractUpdateDefaultExpiryDate, } from '../GenericContract.js';
import * as EntrypointName from '../types/EntrypointName.js';
import * as Timestamp from '../types/Timestamp.js';
import * as TransactionExpiry from '../types/TransactionExpiry.js';
import { REVOKE_DOMAIN, deserializeCIS4CredentialEntry, deserializeCIS4CredentialStatus, deserializeCIS4MetadataResponse, deserializeCIS4RevocationKeys, formatCIS4RegisterCredential, formatCIS4RevokeCredentialHolder, formatCIS4RevokeCredentialIssuer, formatCIS4RevokeCredentialOther, formatCIS4UpdateRevocationKeys, serializeCIS4RegisterCredentialParam, serializeCIS4RevocationDataHolder, serializeCIS4RevocationDataOther, serializeCIS4RevokeCredentialIssuerParam, serializeCIS4UpdateRevocationKeysParam, } from './util.js';
/**
 * Defines methods for performing dry-run invocations of CIS4 contract updates.
 * Is accessible throught the `dryRun` property of a `CIS4Contract` instance.
 */
class CIS4DryRun extends ContractDryRun {
    /**
     * Performs a dry-run invocation of "CIS4.registerCredential"
     *
     * @param {AccountAddress.Type | ContractAddress.Type} sender - Address of the sender of the transfer.
     * @param {CIS4.CredentialInfo} credInfo - the credential info to register
     * @param {HexString} [additionalData] - any additional data to include
     * @param {BlockHash.Type} [blockHash] - The hash of the block to perform the invocation of. Defaults to the latest finalized block on chain.
     *
     * @returns {InvokeContractResult} the contract invocation result, which includes whether or not the invocation succeeded along with the energy spent.
     */
    registerCredential(sender, credInfo, additionalData = '', blockHash) {
        return this.invokeMethod(EntrypointName.fromStringUnchecked('registerCredential'), sender, serializeCIS4RegisterCredentialParam, { credInfo, additionalData }, blockHash);
    }
    /**
     * Performs a dry-run invocation of "CIS4.revokeCredentialIssuer"
     *
     * @param {AccountAddress.Type | ContractAddress.Type} sender - Address of the sender of the transfer.
     * @param {HexString} credHolderPubKey - the public key of the credential holder (hex encoded)
     * @param {string} [reason] - the reason for the revocation
     * @param {HexString} [additionalData] - any additional data to include
     * @param {BlockHash.Type} [blockHash] - The hash of the block to perform the invocation of. Defaults to the latest finalized block on chain.
     *
     * @returns {InvokeContractResult} the contract invocation result, which includes whether or not the invocation succeeded along with the energy spent.
     */
    revokeCredentialAsIssuer(sender, credHolderPubKey, reason, additionalData = '', blockHash) {
        return this.invokeMethod(EntrypointName.fromStringUnchecked('revokeCredentialIssuer'), sender, serializeCIS4RevokeCredentialIssuerParam, { credHolderPubKey, reason, additionalData }, blockHash);
    }
    /**
     * Performs a dry-run invocation of "CIS4.revokeCredentialHolder"
     *
     * @param {AccountAddress.Type | ContractAddress.Type} sender - Address of the sender of the transfer.
     * @param {Web3IdSigner} credHolderSigner - A signer structure for the credential holder
     * @param {bigint} nonce - the nonce of the owner inside the contract
     * @param {Date} expiry - Expiry time of the revocation message
     * @param {string} [reason] - the reason for the revocation
     * @param {BlockHash.Type} [blockHash] - The hash of the block to perform the invocation of. Defaults to the latest finalized block on chain.
     *
     * @returns {InvokeContractResult} the contract invocation result, which includes whether or not the invocation succeeded along with the energy spent.
     */
    async revokeCredentialAsHolder(sender, credHolderSigner, nonce, expiry, reason, blockHash) {
        const credentialPubKey = credHolderSigner.pubKey;
        const entrypoint = EntrypointName.fromStringUnchecked('revokeCredentialHolder');
        const signingData = {
            contractAddress: this.contractAddress,
            entrypoint,
            nonce,
            timestamp: Timestamp.fromDate(expiry),
        };
        const serializedData = serializeCIS4RevocationDataHolder({
            credentialPubKey,
            signingData,
            reason,
        });
        const digest = Buffer.concat([REVOKE_DOMAIN, serializedData]);
        const signature = await credHolderSigner.sign(digest);
        return this.invokeMethod(entrypoint, sender, () => Buffer.concat([signature, serializedData]), // Reuse existing serialization
        undefined, blockHash);
    }
    /**
     * Performs a dry-run invocation of "CIS4.revokeCredentialOther"
     *
     * @param {AccountAddress.Type | ContractAddress.Type} sender - Address of the sender of the transfer.
     * @param {Web3IdSigner} revokerSigner - A signer structure for the credential holder
     * @param {HexString} credentialPubKey - the public key (hex encoded) for the credential to revoke
     * @param {bigint} nonce - the nonce of the owner inside the contract
     * @param {Date} expiry - Expiry time of the revocation message
     * @param {string} [reason] - the reason for the revocation
     * @param {BlockHash.Type} [blockHash] - The hash of the block to perform the invocation of. Defaults to the latest finalized block on chain.
     *
     * @returns {InvokeContractResult} the contract invocation result, which includes whether or not the invocation succeeded along with the energy spent.
     */
    async revokeCredentialAsOther(sender, revokerSigner, credentialPubKey, nonce, expiry, reason, blockHash) {
        const revocationPubKey = revokerSigner.pubKey;
        const entrypoint = EntrypointName.fromStringUnchecked('revokeCredentialOther');
        const signingData = {
            contractAddress: this.contractAddress,
            entrypoint,
            nonce,
            timestamp: Timestamp.fromDate(expiry),
        };
        const serializedData = serializeCIS4RevocationDataOther({
            credentialPubKey,
            signingData,
            revocationPubKey,
            reason,
        });
        const digest = Buffer.concat([REVOKE_DOMAIN, serializedData]);
        const signature = await revokerSigner.sign(digest);
        return this.invokeMethod(entrypoint, sender, () => Buffer.concat([signature, serializedData]), // Reuse existing serialization
        undefined, blockHash);
    }
    /**
     * Performs a dry-run invocation of "CIS4.registerRevocationKeys"
     *
     * @param {AccountAddress.Type | ContractAddress.Type} sender - Address of the sender of the transfer.
     * @param {HexString | HexString[]} keys - a single or list of hex encoded public keys to be used for revocation
     * @param {HexString} [additionalData] - any additional data to include
     * @param {BlockHash.Type} [blockHash] - The hash of the block to perform the invocation of. Defaults to the latest finalized block on chain.
     *
     * @returns {InvokeContractResult} the contract invocation result, which includes whether or not the invocation succeeded along with the energy spent.
     */
    registerRevocationKeys(sender, keys, additionalData = '', blockHash) {
        const ks = Array.isArray(keys) ? keys : [keys];
        return this.invokeMethod(EntrypointName.fromStringUnchecked('registerRevocationKeys'), sender, serializeCIS4UpdateRevocationKeysParam, { additionalData, keys: ks }, blockHash);
    }
    /**
     * Performs a dry-run invocation of "CIS4.removeRevocationKeys"
     *
     * @param {AccountAddress.Type | ContractAddress.Type} sender - Address of the sender of the transfer.
     * @param {HexString | HexString[]} keys - a single or list of hex encoded public keys to be removed
     * @param {HexString} [additionalData] - any additional data to include
     * @param {BlockHash.Type} [blockHash] - The hash of the block to perform the invocation of. Defaults to the latest finalized block on chain.
     *
     * @returns {InvokeContractResult} the contract invocation result, which includes whether or not the invocation succeeded along with the energy spent.
     */
    removeRevocationKeys(sender, keys, additionalData = '', blockHash) {
        const ks = Array.isArray(keys) ? keys : [keys];
        return this.invokeMethod(EntrypointName.fromStringUnchecked('removeRevocationKeys'), sender, serializeCIS4UpdateRevocationKeysParam, { additionalData, keys: ks }, blockHash);
    }
}
/**
 * Defines methods for interacting with CIS4 contracts.
 */
export class CIS4Contract extends CISContract {
    constructor() {
        super(...arguments);
        /**
         * Parameter schemas for each CIS4 update entrypoint.
         * These are returned individually when creating update transactions to be used for serializing
         * a corresponding JSON representation of the parameter.
         */
        this.schema = {
            /** Parameter schema for `registerCredential` entrypoint */
            registerCredential: 'FAACAAAADwAAAGNyZWRlbnRpYWxfaW5mbxQABQAAAAkAAABob2xkZXJfaWQeIAAAABAAAABob2xkZXJfcmV2b2NhYmxlAQoAAAB2YWxpZF9mcm9tDQsAAAB2YWxpZF91bnRpbBUCAAAABAAAAE5vbmUCBAAAAFNvbWUBAQAAAA0MAAAAbWV0YWRhdGFfdXJsFAACAAAAAwAAAHVybBYBBAAAAGhhc2gVAgAAAAQAAABOb25lAgQAAABTb21lAQEAAAAeIAAAAA4AAABhdXhpbGlhcnlfZGF0YRABAg',
            /** Parameter schema for `revokeCredentialHolder` entrypoint */
            revokeCredentialHolder: 'FAACAAAACQAAAHNpZ25hdHVyZR5AAAAABAAAAGRhdGEUAAMAAAANAAAAY3JlZGVudGlhbF9pZB4gAAAADAAAAHNpZ25pbmdfZGF0YRQABAAAABAAAABjb250cmFjdF9hZGRyZXNzDAsAAABlbnRyeV9wb2ludBYBBQAAAG5vbmNlBQkAAAB0aW1lc3RhbXANBgAAAHJlYXNvbhUCAAAABAAAAE5vbmUCBAAAAFNvbWUBAQAAABQAAQAAAAYAAAByZWFzb24WAA',
            /** Parameter schema for `revokeCredentialIssuer` entrypoint */
            revokeCredentialIssuer: 'FAADAAAADQAAAGNyZWRlbnRpYWxfaWQeIAAAAAYAAAByZWFzb24VAgAAAAQAAABOb25lAgQAAABTb21lAQEAAAAUAAEAAAAGAAAAcmVhc29uFgAOAAAAYXV4aWxpYXJ5X2RhdGEQAQI',
            /** Parameter schema for `revokeCredentialOther` entrypoint */
            revokeCredentialOther: 'FAACAAAACQAAAHNpZ25hdHVyZR5AAAAABAAAAGRhdGEUAAQAAAANAAAAY3JlZGVudGlhbF9pZB4gAAAADAAAAHNpZ25pbmdfZGF0YRQABAAAABAAAABjb250cmFjdF9hZGRyZXNzDAsAAABlbnRyeV9wb2ludBYBBQAAAG5vbmNlBQkAAAB0aW1lc3RhbXANDgAAAHJldm9jYXRpb25fa2V5HiAAAAAGAAAAcmVhc29uFQIAAAAEAAAATm9uZQIEAAAAU29tZQEBAAAAFAABAAAABgAAAHJlYXNvbhYA',
            /** Parameter schema for `registerRevocationKeys` entrypoint */
            registerRevocationKeys: 'FAACAAAABAAAAGtleXMQAR4gAAAADgAAAGF1eGlsaWFyeV9kYXRhEAEC',
            /** Parameter schema for `removeRevocationKeys` entrypoint */
            removeRevocationKeys: 'FAACAAAABAAAAGtleXMQAR4gAAAADgAAAGF1eGlsaWFyeV9kYXRhEAEC',
        };
    }
    /**
     * Creates a new `CIS4Contract` instance by querying the node for the necessary information through the supplied `grpcClient`.
     *
     * @param {ConcordiumGRPCClient} grpcClient - The client used for contract invocations and updates.
     * @param {ContractAddress} contractAddress - Address of the contract instance.
     *
     * @throws If `InstanceInfo` could not be received for the contract,
     * or if the contract name could not be parsed from the information received from the node.
     */
    static async create(grpcClient, contractAddress) {
        const contractName = await super.getContractName(grpcClient, contractAddress);
        return new CIS4Contract(grpcClient, contractAddress, contractName);
    }
    makeDryRunInstance(grpcClient, contractAddress, contractName) {
        return new CIS4DryRun(grpcClient, contractAddress, contractName);
    }
    /**
     * Look up an entry in the registry by the public key of its holder.
     *
     * @param {HexString} credHolderPubKey - public key identifying the credential holder
     * @param {BlockHash.Type} [blockHash] - block to perform query at.
     *
     * @returns {CIS4.CredentialEntry} a corresponding credential entry.
     */
    credentialEntry(credHolderPubKey, blockHash) {
        return this.invokeView(EntrypointName.fromStringUnchecked('credentialEntry'), (k) => Buffer.from(k, 'hex'), deserializeCIS4CredentialEntry, credHolderPubKey, blockHash);
    }
    /**
     * Look up the status of a credential by the public key of its holder.
     *
     * @param {HexString} credHolderPubKey - public key identifying the credential holder
     * @param {BlockHash.Type} [blockHash] - block to perform query at.
     *
     * @returns {CIS4.CredentialStatus} a corresponding credential status.
     */
    credentialStatus(credHolderPubKey, blockHash) {
        return this.invokeView(EntrypointName.fromStringUnchecked('credentialStatus'), (k) => Buffer.from(k, 'hex'), deserializeCIS4CredentialStatus, credHolderPubKey, blockHash);
    }
    /**
     * Get list of all revocation keys and their corresponding nonces.
     *
     * @param {BlockHash.Type} [blockHash] - block to perform query at.
     *
     * @returns {CIS4.RevocationKeyWithNonce[]} the revocation keys wityh corresponding nonces.
     */
    revocationKeys(blockHash) {
        return this.invokeView(EntrypointName.fromStringUnchecked('revocationKeys'), () => Buffer.alloc(0), deserializeCIS4RevocationKeys, undefined, blockHash);
    }
    /**
     * Get the registry metadata.
     *
     * @param {BlockHash.Type} [blockHash] - block to perform query at.
     *
     * @returns {CIS4.MetadataUrl} a metadata URL.
     */
    registryMetadata(blockHash) {
        return this.invokeView(EntrypointName.fromStringUnchecked('registryMetadata'), () => Buffer.alloc(0), deserializeCIS4MetadataResponse, undefined, blockHash);
    }
    /**
     * Get the {@link AccountAddress} public key of the issuer.
     *
     * @param {BlockHash.Type} [blockHash] - block to perform query at.
     *
     * @returns {HexString} a hex encoded public key.
     */
    issuer(blockHash) {
        return this.invokeView(EntrypointName.fromStringUnchecked('issuer'), () => Buffer.alloc(0), (value) => value, undefined, blockHash);
    }
    /**
     * Create the details necessary to submit a CIS4.registerCredential update transaction.
     *
     * @param {CreateContractTransactionMetadata} metadata - transaction metadata
     * @param {CIS4.CredentialInfo} credInfo - the credential info to register
     * @param {HexString} [additionalData] - any additional data to include
     *
     * @returns {ContractUpdateTransactionWithSchema} Transaction data for a CIS4.registerCredential update.
     */
    createRegisterCredential(metadata, credInfo, additionalData = '') {
        return this.createUpdateTransaction(EntrypointName.fromStringUnchecked('registerCredential'), serializeCIS4RegisterCredentialParam, metadata, { credInfo, additionalData }, formatCIS4RegisterCredential);
    }
    /**
     * Submit CIS4.registerCredential update transaction.
     *
     * @param {AccountSigner} signer - to be used for signing the transaction sent to the node.
     * @param {ContractTransactionMetadata} metadata - transaction metadata
     * @param {CIS4.CredentialInfo} credInfo - the credential info to register
     * @param {HexString} [additionalData] - any additional data to include
     *
     * @returns {TransactionHash.Type} The hash of the submitted transaction
     */
    registerCredential(signer, metadata, credInfo, additionalData = '') {
        const transaction = this.createRegisterCredential(metadata, credInfo, additionalData);
        return this.sendUpdateTransaction(transaction, metadata, signer);
    }
    /**
     * Create the details necessary to submit a CIS4.revokeCredentialIssuer update transaction.
     *
     * @param {CreateContractTransactionMetadata} metadata - transaction metadata
     * @param {HexString} credHolderPubKey - the public key of the credential holder (hex encoded)
     * @param {string} [reason] - the reason for the revocation
     * @param {HexString} [additionalData] - any additional data to include
     *
     * @returns {ContractUpdateTransactionWithSchema} Transaction data for a CIS4.revokeCredentialIssuer update.
     */
    createRevokeCredentialAsIssuer(metadata, credHolderPubKey, reason, additionalData = '') {
        return this.createUpdateTransaction(EntrypointName.fromStringUnchecked('revokeCredentialIssuer'), serializeCIS4RevokeCredentialIssuerParam, metadata, { credHolderPubKey, reason, additionalData }, formatCIS4RevokeCredentialIssuer);
    }
    /**
     * Submit CIS4.revokeCredentialIssuer update transaction.
     *
     * @param {AccountSigner} signer - to be used for signing the transaction sent to the node.
     * @param {ContractTransactionMetadata} metadata - transaction metadata
     * @param {HexString} credHolderPubKey - the public key of the credential holder (hex encoded)
     * @param {string} [reason] - the reason for the revocation
     * @param {HexString} [additionalData] - any additional data to include
     *
     * @returns {TransactionHash.Type} The hash of the submitted transaction
     */
    revokeCredentialAsIssuer(signer, metadata, credHolderPubKey, reason, additionalData = '') {
        const transaction = this.createRevokeCredentialAsIssuer(metadata, credHolderPubKey, reason, additionalData);
        return this.sendUpdateTransaction(transaction, metadata, signer);
    }
    /**
     * Create the details necessary to submit a CIS4.revokeCredentialHolder update transaction.
     *
     * @param {CreateContractTransactionMetadata} metadata - transaction metadata
     * @param {Web3IdSigner} credHolderSigner - A signer structure for the credential holder
     * @param {bigint} nonce - the nonce of the owner inside the contract
     * @param {Date} expiry - Expiry time of the revocation message
     * @param {string} [reason] - the reason for the revocation
     *
     * @returns {ContractUpdateTransactionWithSchema} Transaction data for a CIS4.revokeCredentialHolder update.
     */
    async createRevokeCredentialAsHolder(metadata, credHolderSigner, nonce, expiry, reason) {
        const credentialPubKey = credHolderSigner.pubKey;
        const entrypoint = EntrypointName.fromStringUnchecked('revokeCredentialHolder');
        const signingData = {
            contractAddress: this.contractAddress,
            entrypoint,
            nonce,
            timestamp: Timestamp.fromDate(expiry),
        };
        const serializedData = serializeCIS4RevocationDataHolder({
            credentialPubKey,
            signingData,
            reason,
        });
        const digest = Buffer.concat([REVOKE_DOMAIN, serializedData]);
        const signature = await credHolderSigner.sign(digest);
        return this.createUpdateTransaction(entrypoint, () => Buffer.concat([signature, serializedData]), // Reuse existing serialization
        metadata, {
            signature: signature.toString('hex'),
            data: { credentialPubKey, signingData, reason },
        }, formatCIS4RevokeCredentialHolder);
    }
    /**
     * Submit CIS4.revokeCredentialHolder update transaction.
     * The revocation message is set to expire at the same time as the transaction (from `metadata.expiry`)
     *
     * @param {AccountSigner} signer - to be used for signing the transaction sent to the node.
     * @param {ContractTransactionMetadata} metadata - transaction metadata
     * @param {Web3IdSigner} credHolderSigner - A signer structure for the credential holder
     * @param {bigint} nonce - the nonce of the owner inside the contract
     * @param {string} [reason] - the reason for the revocation
     *
     * @returns {TransactionHash.Type} The hash of the submitted transaction
     */
    async revokeCredentialAsHolder(signer, metadata, credHolderSigner, nonce, reason) {
        const transaction = await this.createRevokeCredentialAsHolder(metadata, credHolderSigner, nonce, TransactionExpiry.toDate(metadata.expiry ?? getContractUpdateDefaultExpiryDate()), reason);
        return this.sendUpdateTransaction(transaction, metadata, signer);
    }
    /**
     * Create the details necessary to submit a CIS4.revokeCredentialOther update transaction.
     *
     * @param {CreateContractTransactionMetadata} metadata - transaction metadata
     * @param {Web3IdSigner} revokerSigner - A signer structure for the revoker
     * @param {HexString} credentialPubKey - the public key (hex encoded) for the credential to revoke
     * @param {bigint} nonce - the nonce of the owner inside the contract
     * @param {Date} expiry - Expiry time of the revocation message
     * @param {string} [reason] - the reason for the revocation
     *
     * @returns {ContractUpdateTransactionWithSchema} Transaction data for a CIS4.revokeCredentialOther update.
     */
    async createRevokeCredentialAsOther(metadata, revokerSigner, credentialPubKey, nonce, expiry, reason) {
        const revocationPubKey = revokerSigner.pubKey;
        const entrypoint = EntrypointName.fromStringUnchecked('revokeCredentialOther');
        const signingData = {
            contractAddress: this.contractAddress,
            entrypoint,
            nonce,
            timestamp: Timestamp.fromDate(expiry),
        };
        const serializedData = serializeCIS4RevocationDataOther({
            credentialPubKey,
            revocationPubKey,
            signingData,
            reason,
        });
        const digest = Buffer.concat([REVOKE_DOMAIN, serializedData]);
        const signature = await revokerSigner.sign(digest);
        return this.createUpdateTransaction(entrypoint, () => Buffer.concat([signature, serializedData]), // Reuse existing serialization
        metadata, {
            signature: signature.toString('hex'),
            data: {
                credentialPubKey,
                signingData,
                revocationPubKey,
                reason,
            },
        }, formatCIS4RevokeCredentialOther);
    }
    /**
     * Submit CIS4.revokeCredentialOther update transaction.
     * The revocation message is set to expire at the same time as the transaction (from `metadata.expiry`)
     *
     * @param {AccountSigner} signer - to be used for signing the transaction sent to the node.
     * @param {ContractTransactionMetadata} metadata - transaction metadata
     * @param {Web3IdSigner} revokerSigner - A signer structure for the credential holder
     * @param {HexString} credentialPubKey - the public key (hex encoded) for the credential to revoke
     * @param {bigint} nonce - the nonce of the owner inside the contract
     * @param {string} [reason] - the reason for the revocation
     *
     * @returns {TransactionHash.Type} The hash of the submitted transaction
     */
    async revokeCredentialAsOther(signer, metadata, revokerSigner, credentialPubKey, nonce, reason) {
        const transaction = await this.createRevokeCredentialAsOther(metadata, revokerSigner, credentialPubKey, nonce, TransactionExpiry.toDate(metadata.expiry ?? getContractUpdateDefaultExpiryDate()), reason);
        return this.sendUpdateTransaction(transaction, metadata, signer);
    }
    /**
     * Create the details necessary to submit a CIS4.registerRevicationKeys update transaction.
     *
     * @param {CreateContractTransactionMetadata} metadata - transaction metadata
     * @param {HexString | HexString[]} keys - a single or list of hex encoded public keys to be used for revocation
     * @param {HexString} [additionalData] - any additional data to include
     *
     * @returns {ContractUpdateTransactionWithSchema} Transaction data for a CIS4.registerRevicationKeys update.
     */
    createRegisterRevocationKeys(metadata, keys, additionalData = '') {
        const ks = Array.isArray(keys) ? keys : [keys];
        return this.createUpdateTransaction(EntrypointName.fromStringUnchecked('registerRevocationKeys'), serializeCIS4UpdateRevocationKeysParam, metadata, { additionalData, keys: ks }, formatCIS4UpdateRevocationKeys);
    }
    /**
     * Submit CIS4.registerRevocationKeys update transaction.
     *
     * @param {AccountSigner} signer - to be used for signing the transaction sent to the node.
     * @param {ContractTransactionMetadata} metadata - transaction metadata
     * @param {HexString | HexString[]} keys - a single or list of hex encoded public keys to be used for revocation
     * @param {HexString} [additionalData] - any additional data to include
     *
     * @returns {TransactionHash.Type} The hash of the submitted transaction
     */
    registerRevocationKeys(signer, metadata, keys, additionalData = '') {
        const transaction = this.createRegisterRevocationKeys(metadata, keys, additionalData);
        return this.sendUpdateTransaction(transaction, metadata, signer);
    }
    /**
     * Create the details necessary to submit a CIS4.removeRevicationKeys update transaction.
     *
     * @param {CreateContractTransactionMetadata} metadata - transaction metadata
     * @param {HexString | HexString[]} keys - a single or list of hex encoded public keys to be removed
     * @param {HexString} [additionalData] - any additional data to include
     *
     * @returns {ContractUpdateTransactionWithSchema} Transaction data for a CIS4.removeRevicationKeys update.
     */
    createRemoveRevocationKeys(metadata, keys, additionalData = '') {
        const ks = Array.isArray(keys) ? keys : [keys];
        return this.createUpdateTransaction(EntrypointName.fromStringUnchecked('removeRevocationKeys'), serializeCIS4UpdateRevocationKeysParam, metadata, { additionalData, keys: ks }, formatCIS4UpdateRevocationKeys);
    }
    /**
     * Submit CIS4.removeRevocationKeys update transaction.
     *
     * @param {AccountSigner} signer - to be used for signing the transaction sent to the node.
     * @param {ContractTransactionMetadata} metadata - transaction metadata
     * @param {HexString | HexString[]} keys - a single or list of hex encoded public keys to be removed
     * @param {HexString} [additionalData] - any additional data to include
     *
     * @returns {TransactionHash.Type} The hash of the submitted transaction
     */
    removeRevocationKeys(signer, metadata, keys, additionalData = '') {
        const transaction = this.createRemoveRevocationKeys(metadata, keys, additionalData);
        return this.sendUpdateTransaction(transaction, metadata, signer);
    }
}
//# sourceMappingURL=CIS4Contract.js.map