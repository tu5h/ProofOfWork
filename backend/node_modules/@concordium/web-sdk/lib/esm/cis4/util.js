// self-referencing not allowed by eslint resolver
// eslint-disable-next-line import/no-extraneous-dependencies
import * as ed from '@concordium/web-sdk/shims/ed25519';
import { Buffer } from 'buffer/index.js';
import { deserializeCIS2MetadataUrl, serializeCIS2MetadataUrl, serializeContractAddress, serializeReceiveHookName, } from '../cis2/util.js';
import { Cursor, makeDeserializeListResponse } from '../deserializationHelpers.js';
import { toOptionJson } from '../schemaTypes.js';
import { encodeBool, encodeWord16, encodeWord64, makeSerializeOptional, packBufferWithWord8Length, packBufferWithWord16Length, } from '../serializationHelpers.js';
import { getSignature } from '../signHelpers.js';
import { TransactionKindString, TransactionSummaryType, } from '../types.js';
import * as ContractEvent from '../types/ContractEvent.js';
import * as EntrypointName from '../types/EntrypointName.js';
import * as Timestamp from '../types/Timestamp.js';
/** Holds all types related to CIS4 */
// eslint-disable-next-line @typescript-eslint/no-namespace
export var CIS4;
(function (CIS4) {
    /** Response type for `credentialStatus` query */
    let CredentialStatus;
    (function (CredentialStatus) {
        /** The credential is active */
        CredentialStatus[CredentialStatus["Active"] = 0] = "Active";
        /** The credential has been revoked */
        CredentialStatus[CredentialStatus["Revoked"] = 1] = "Revoked";
        /** The credential has expired */
        CredentialStatus[CredentialStatus["Expired"] = 2] = "Expired";
        /** The credential has not been activated */
        CredentialStatus[CredentialStatus["NotActivated"] = 3] = "NotActivated";
    })(CredentialStatus = CIS4.CredentialStatus || (CIS4.CredentialStatus = {}));
    /** A type of credential revoker. Either the issuer of the credential,
     * holder of the credential, or a third party authority. */
    let RevokerType;
    (function (RevokerType) {
        /** The issuer of the credential */
        RevokerType[RevokerType["Issuer"] = 0] = "Issuer";
        /** The holder of the credential */
        RevokerType[RevokerType["Holder"] = 1] = "Holder";
        /** A third party credential authority */
        RevokerType[RevokerType["Other"] = 2] = "Other";
    })(RevokerType = CIS4.RevokerType || (CIS4.RevokerType = {}));
    /** An action determining if a revocation key is registered or removed */
    let RevocationKeyAction;
    (function (RevocationKeyAction) {
        /** Register a revocation key */
        RevocationKeyAction[RevocationKeyAction["Register"] = 0] = "Register";
        /** Remove a revocation key */
        RevocationKeyAction[RevocationKeyAction["Remove"] = 1] = "Remove";
    })(RevocationKeyAction = CIS4.RevocationKeyAction || (CIS4.RevocationKeyAction = {}));
    /** A type of CIS-4 event */
    let EventType;
    (function (EventType) {
        /** A credential was registered */
        EventType[EventType["RegisterCredential"] = 0] = "RegisterCredential";
        /** A credential was revoked */
        EventType[EventType["RevokeCredential"] = 1] = "RevokeCredential";
        /** The issuer metadata was updated */
        EventType[EventType["IssuerMetadata"] = 2] = "IssuerMetadata";
        /** The credential metadata was updated */
        EventType[EventType["CredentialMetadata"] = 3] = "CredentialMetadata";
        /** The credential schema reference was updated */
        EventType[EventType["CredentialSchemaRef"] = 4] = "CredentialSchemaRef";
        /** A revocation key was registered or removed */
        EventType[EventType["RevocationKey"] = 5] = "RevocationKey";
        /** A custom event outside CIS-4 */
        EventType[EventType["Custom"] = 6] = "Custom";
    })(EventType = CIS4.EventType || (CIS4.EventType = {}));
})(CIS4 || (CIS4 = {}));
/**
 * A wrapper around an ed25519 keypair which is used by {@link CIS4Contract} methods for signing as various entities.
 */
export class Web3IdSigner {
    /**
     * Builds a `Web3IdSigner` from ed25519 keypair
     *
     * @param {HexString} privateKey - the ed25519 private key used for signing
     * @param {HexString} publicKey - the ed25519 public key used for verifcation of signature
     */
    constructor(privateKey, publicKey) {
        this.privateKey = privateKey;
        this.publicKey = publicKey;
    }
    /**
     * Builds a `Web3IdSigner` from ed25519 private key
     *
     * @param {HexString} privateKey - the ed25519 private key used for signing
     *
     * @returns {Web3IdSigner} signer structure.
     */
    static async from(privateKey) {
        const publicKey = Buffer.from(await ed.getPublicKeyAsync(Buffer.from(privateKey, 'hex'))).toString('hex');
        return new Web3IdSigner(privateKey, publicKey);
    }
    /** Public key of signer */
    get pubKey() {
        return this.publicKey;
    }
    /**
     * Signs the message given
     *
     * @param {ArrayBuffer} message - the message to sign
     *
     * @returns {Buffer} the signature on `message`
     */
    async sign(message) {
        return getSignature(message, this.privateKey);
    }
}
/**
 * Expected prefix of messages signed for CIS4 revocation entrypoints.
 */
export const REVOKE_DOMAIN = Buffer.from('WEB3ID:REVOKE', 'utf8');
const deserializeOptional = (cursor, fun) => {
    const hasValue = cursor.read(1).readUInt8(0);
    if (!hasValue) {
        return undefined;
    }
    return fun(cursor);
};
export function serializeDate(date) {
    return encodeWord64(BigInt(date.value), true);
}
export function deserializeDate(cursor) {
    const value = cursor.read(8).readBigInt64LE(0);
    return Timestamp.fromMillis(Number(value));
}
function deserializeEd25519PublicKey(cursor) {
    return cursor.read(32).toString('hex');
}
function deserializeReason(cursor) {
    return deserializeOptional(cursor, (c) => {
        const len = c.read(1).readUInt8(0);
        return c.read(len).toString('utf8');
    });
}
function serializeCIS4CredentialInfo(credInfo) {
    const holderPubKey = Buffer.from(credInfo.holderPubKey, 'hex');
    const holderRevocable = encodeBool(credInfo.holderRevocable);
    const validFrom = serializeDate(credInfo.validFrom);
    const validUntil = makeSerializeOptional(serializeDate)(credInfo.validUntil);
    const metadataUrl = serializeCIS2MetadataUrl(credInfo.metadataUrl);
    return Buffer.concat([holderPubKey, holderRevocable, validFrom, validUntil, metadataUrl]);
}
function serializeAdditionalData(data) {
    return packBufferWithWord16Length(Buffer.from(data, 'hex'), true);
}
/**
 * Serializes {@link CIS4.RegisterCredentialParam} into bytes which can be
 * supplied as parameters to `registerCredential` entrypoints on CIS4 contracts
 *
 * @param {CIS4.RegisterCredentialParam} param - The parameters to serialize
 *
 * @returns {Buffer} the parameters serialized to bytes
 */
export function serializeCIS4RegisterCredentialParam(param) {
    const credInfo = serializeCIS4CredentialInfo(param.credInfo);
    const additionalData = serializeAdditionalData(param.additionalData);
    return Buffer.concat([credInfo, additionalData]);
}
function deserializeCIS4CredentialInfo(cursor) {
    const holderPubKey = deserializeEd25519PublicKey(cursor);
    const holderRevocable = cursor.read(1).readUInt8(0) === 1;
    const validFrom = deserializeDate(cursor);
    const validUntil = deserializeOptional(cursor, deserializeDate);
    const metadataUrl = deserializeCIS2MetadataUrl(cursor);
    return {
        holderPubKey,
        holderRevocable,
        validFrom,
        validUntil,
        metadataUrl,
    };
}
/**
 * Attemps to deserializes a value into {@link CIS4.CredentialEntry}
 *
 * @param {HexString} value - The value (hex encoded) to deserialize
 *
 * @throws If deserialization fails
 *
 * @returns {CIS4.CredentialEntry} The credential entry
 */
export function deserializeCIS4CredentialEntry(value) {
    const cursor = Cursor.fromHex(value);
    const credentialInfo = deserializeCIS4CredentialInfo(cursor);
    const schemaRef = deserializeCIS2MetadataUrl(cursor);
    const revocationNonce = cursor.read(8).readBigInt64LE(0).valueOf();
    return {
        credentialInfo,
        schemaRef,
        revocationNonce,
    };
}
/**
 * Attemps to deserializes a value into {@link CIS4.CredentialStatus}
 *
 * @param {HexString} value - The value (hex encoded) to deserialize
 *
 * @throws If deserialization fails
 *
 * @returns {CIS4.CredentialStatus} The credential status
 */
export function deserializeCIS4CredentialStatus(value) {
    const b = Buffer.from(value, 'hex');
    return b.readUInt8(0);
}
function deserializeCIS4RevocationKey(cursor) {
    const key = deserializeEd25519PublicKey(cursor);
    const nonce = cursor.read(8).readBigInt64LE(0).valueOf();
    return {
        key,
        nonce,
    };
}
/**
 * Attemps to deserializes a value into a list of {@link CIS4.RevocationKeyWithNonce}
 *
 * @param {HexString} value - The value (hex encoded) to deserialize
 *
 * @throws If deserialization fails
 *
 * @returns {CIS4.RevocationKeyWithNonce[]} The revocation keys
 */
export const deserializeCIS4RevocationKeys = makeDeserializeListResponse(deserializeCIS4RevocationKey);
function formatAdditionalData(data) {
    return Buffer.from(data, 'hex').toJSON().data;
}
/**
 * Format {@link CIS4.RegisterCredentialParam} as JSON compatible with serialization with corresponding schema.
 */
export function formatCIS4RegisterCredential({ credInfo, additionalData, }) {
    return {
        credential_info: {
            holder_id: credInfo.holderPubKey,
            holder_revocable: credInfo.holderRevocable,
            valid_from: Timestamp.toSchemaValue(credInfo.validFrom),
            valid_until: toOptionJson(credInfo.validUntil === undefined ? undefined : Timestamp.toSchemaValue(credInfo.validUntil)),
            metadata_url: {
                url: credInfo.metadataUrl.url,
                hash: toOptionJson(credInfo.metadataUrl.hash),
            },
        },
        auxiliary_data: formatAdditionalData(additionalData),
    };
}
function serializeReason(reason) {
    const b = Buffer.from(reason);
    return packBufferWithWord8Length(b);
}
/**
 * Serializes {@link CIS4.RevokeCredentialIssuerParam} into bytes which can be
 * supplied as parameters to `revokeCredentialIssuer` entrypoints on CIS4 contracts
 *
 * @param {CIS4.RevokeCredentialIssuerParam} param - The parameters to serialize
 *
 * @returns {Buffer} the parameters serialized to bytes
 */
export function serializeCIS4RevokeCredentialIssuerParam(param) {
    const credHolderPubKey = Buffer.from(param.credHolderPubKey, 'hex');
    const reason = makeSerializeOptional(serializeReason)(param.reason);
    const additionalData = serializeAdditionalData(param.additionalData);
    return Buffer.concat([credHolderPubKey, reason, additionalData]);
}
/**
 * Format {@link CIS4.RevokeCredentialIssuerParam} as JSON compatible with serialization with corresponding schema.
 */
export function formatCIS4RevokeCredentialIssuer({ credHolderPubKey, reason, additionalData, }) {
    return {
        credential_id: credHolderPubKey,
        reason: toOptionJson(reason ? { reason } : undefined),
        auxiliary_data: formatAdditionalData(additionalData),
    };
}
/**
 * Serializes {@link CIS4.RevocationDataHolder} into bytes which can be
 * supplied as parameters to `revokeCredentialHolder` entrypoints on CIS4 contracts prefixed
 * with a signature on the data
 *
 * @param {CIS4.RevocationDataHolder} data - The data to serialize
 *
 * @returns {Buffer} the data serialized to bytes
 */
export function serializeCIS4RevocationDataHolder(data) {
    const credentialPubKey = Buffer.from(data.credentialPubKey, 'hex');
    const contractAddress = serializeContractAddress(data.signingData.contractAddress);
    const entrypoint = serializeReceiveHookName(data.signingData.entrypoint);
    const nonce = encodeWord64(data.signingData.nonce, true);
    const timestamp = serializeDate(data.signingData.timestamp);
    const reason = makeSerializeOptional(serializeReason)(data.reason);
    return Buffer.concat([credentialPubKey, contractAddress, entrypoint, nonce, timestamp, reason]);
}
/**
 * Format {@link CIS4.RevokeCredentialHolderParam} as JSON compatible with serialization with corresponding schema.
 */
export function formatCIS4RevokeCredentialHolder({ signature, data, }) {
    const reason = data.reason;
    return {
        signature: signature,
        data: {
            credential_id: data.credentialPubKey,
            signing_data: {
                contract_address: {
                    index: Number(data.signingData.contractAddress.index),
                    subindex: Number(data.signingData.contractAddress.subindex),
                },
                entry_point: EntrypointName.toString(data.signingData.entrypoint),
                nonce: Number(data.signingData.nonce),
                timestamp: Timestamp.toSchemaValue(data.signingData.timestamp),
            },
            reason: toOptionJson(reason ? { reason } : undefined),
        },
    };
}
/**
 * Serializes {@link CIS4.RevocationDataOther} into bytes which can be
 * supplied as parameters to `revokeCredentialOther` entrypoints on CIS4 contracts prefixed
 * with a signature on the data
 *
 * @param {CIS4.RevocationDataOther} data - The data to serialize
 *
 * @returns {Buffer} the data serialized to bytes
 */
export function serializeCIS4RevocationDataOther(data) {
    const credentialPubKey = Buffer.from(data.credentialPubKey, 'hex');
    const contractAddress = serializeContractAddress(data.signingData.contractAddress);
    const entrypoint = serializeReceiveHookName(data.signingData.entrypoint);
    const nonce = encodeWord64(data.signingData.nonce);
    const timestamp = serializeDate(data.signingData.timestamp);
    const revocationPubKey = Buffer.from(data.revocationPubKey, 'hex');
    const reason = makeSerializeOptional(serializeReason)(data.reason);
    return Buffer.concat([credentialPubKey, contractAddress, entrypoint, nonce, timestamp, revocationPubKey, reason]);
}
/**
 * Format {@link CIS4.RevokeCredentialOtherParam} as JSON compatible with serialization with corresponding schema.
 */
export function formatCIS4RevokeCredentialOther({ signature, data, }) {
    const reason = data.reason;
    return {
        signature: signature,
        data: {
            credential_id: data.credentialPubKey,
            signing_data: {
                contract_address: {
                    index: Number(data.signingData.contractAddress.index),
                    subindex: Number(data.signingData.contractAddress.subindex),
                },
                entry_point: EntrypointName.toString(data.signingData.entrypoint),
                nonce: Number(data.signingData.nonce),
                timestamp: Timestamp.toSchemaValue(data.signingData.timestamp),
            },
            revocation_key: data.revocationPubKey,
            reason: toOptionJson(reason ? { reason } : undefined),
        },
    };
}
/**
 * Serializes {@link CIS4.UpdateRevocationKeysParam} into bytes which can be
 * supplied as parameters to `registerRevocationKeys` and `removeRevocationKeys`
 * entrypoints on CIS4 contracts
 *
 * @param {CIS4.RevokeCredentialIssuerParam} param - The parameters to serialize
 *
 * @returns {Buffer} the parameters serialized to bytes
 */
export function serializeCIS4UpdateRevocationKeysParam(param) {
    const ks = param.keys.map((k) => Buffer.from(k, 'hex'));
    const numKeys = encodeWord16(ks.length, true);
    const additionalData = serializeAdditionalData(param.additionalData);
    return Buffer.concat([numKeys, ...ks, additionalData]);
}
function deserializeCredentialType(cursor) {
    const len = cursor.read(1).readUInt8(0);
    return cursor.read(len).toString('utf8');
}
/**
 * Format {@link CIS4.UpdateRevocationKeysParam} as JSON compatible with serialization with corresponding schema.
 */
export function formatCIS4UpdateRevocationKeys({ keys, additionalData, }) {
    return { keys, auxiliary_data: formatAdditionalData(additionalData) };
}
/**
 * Attemps to deserializes a value into a list of {@link CIS4.MetadataResponse}
 *
 * @param {HexString} value - The value (hex encoded) to deserialize
 *
 * @throws If deserialization fails
 *
 * @returns {CIS4.MetadataResponse} The metadata
 */
export function deserializeCIS4MetadataResponse(value) {
    const cursor = Cursor.fromHex(value);
    const issuerMetadata = deserializeCIS2MetadataUrl(cursor);
    const credentialType = deserializeCredentialType(cursor);
    const credentialSchema = deserializeCIS2MetadataUrl(cursor);
    return { issuerMetadata, credentialType, credentialSchema };
}
/**
 * Deserializes a CIS-4 event according to the CIS-4 standard.
 *
 * @param {ContractEvent.Type} event - The event to deserialize
 *
 * @returns {CIS4.Event} The deserialized event
 *
 * @throws If the event is not custom (starts with an unreserved tag)
 * and the event cannot be deserialized to a valid CIS-4 event
 */
export function deserializeCIS4Event(event) {
    // An empty buffer is a valid custom event
    if (event.buffer.length === 0) {
        return {
            type: CIS4.EventType.Custom,
            data: event.buffer,
        };
    }
    const cursor = Cursor.fromBuffer(event.buffer);
    const tag = cursor.read(1).readUInt8(0);
    if (tag == 249) {
        const credentialPubKey = deserializeEd25519PublicKey(cursor);
        const schemaRef = deserializeCIS2MetadataUrl(cursor);
        const credentialType = deserializeCredentialType(cursor);
        const metadataUrl = deserializeCIS2MetadataUrl(cursor);
        return {
            type: CIS4.EventType.RegisterCredential,
            credentialPubKey,
            schemaRef,
            credentialType,
            metadataUrl,
        };
    }
    else if (tag == 248) {
        const credentialPubKey = deserializeEd25519PublicKey(cursor);
        const revokerType = cursor.read(1).readUInt8(0);
        let revoker;
        if (revokerType == 0) {
            revoker = {
                type: CIS4.RevokerType.Issuer,
            };
        }
        else if (revokerType == 1) {
            revoker = {
                type: CIS4.RevokerType.Holder,
            };
        }
        else if (revokerType == 2) {
            const key = deserializeEd25519PublicKey(cursor);
            revoker = {
                type: CIS4.RevokerType.Other,
                key,
            };
        }
        else {
            throw new Error('Failed deserializing CIS-4 RevokeCredential event: Unknown revoker type');
        }
        const reason = deserializeReason(cursor);
        return {
            type: CIS4.EventType.RevokeCredential,
            credentialPubKey,
            revoker,
            reason,
        };
    }
    else if (tag == 247) {
        const metadataUrl = deserializeCIS2MetadataUrl(cursor);
        return {
            type: CIS4.EventType.IssuerMetadata,
            metadataUrl,
        };
    }
    else if (tag == 246) {
        const credentialPubKey = deserializeEd25519PublicKey(cursor);
        const metadataUrl = deserializeCIS2MetadataUrl(cursor);
        return {
            type: CIS4.EventType.CredentialMetadata,
            credentialPubKey,
            metadataUrl,
        };
    }
    else if (tag == 245) {
        const credentialType = deserializeCredentialType(cursor);
        const schemaRef = deserializeCIS2MetadataUrl(cursor);
        return {
            type: CIS4.EventType.CredentialSchemaRef,
            credentialType,
            schemaRef,
        };
    }
    else if (tag == 244) {
        const key = deserializeEd25519PublicKey(cursor);
        const actionByte = cursor.read(1).readUInt8(0);
        let action;
        if (actionByte == 0) {
            action = CIS4.RevocationKeyAction.Register;
        }
        else if (actionByte == 1) {
            action = CIS4.RevocationKeyAction.Remove;
        }
        else {
            throw new Error('Failed deserializing CIS-4 RevocationKey event: Unknown revocation key action');
        }
        return {
            type: CIS4.EventType.RevocationKey,
            key,
            action,
        };
    }
    else {
        return {
            type: CIS4.EventType.Custom,
            data: event.buffer,
        };
    }
}
/**
 * Deserializes a successful contract invokation to a list of all CIS-4 events
 * (skipping custom events) according to the CIS-4 standard.
 *
 * @param {InvokeContractSuccessResult} result - The contract invokation result to deserialize
 *
 * @returns {CIS4.NonCustomEvent[]} The deserialized events
 */
export function deserializeCIS4EventsFromInvokationResult(result) {
    return deserializeCIS4ContractTraceEvents(result.events);
}
/**
 * Deserializes all CIS-4 events (skipping custom events) from a {@linkcode BlockItemSummary}.
 *
 * @param {BlockItemSummary} summary - The summary to deserialize
 *
 * @returns {CIS4.NonCustomEvent[]} The deserialized events
 */
export function deserializeCIS4EventsFromSummary(summary) {
    if (summary.type !== TransactionSummaryType.AccountTransaction) {
        return [];
    }
    switch (summary.transactionType) {
        case TransactionKindString.Update:
            return deserializeCIS4ContractTraceEvents(summary.events);
        case TransactionKindString.InitContract:
            const deserializedEvents = [];
            for (const event of summary.contractInitialized.events) {
                const deserializedEvent = deserializeCIS4Event(ContractEvent.fromHexString(event));
                if (deserializedEvent.type !== CIS4.EventType.Custom) {
                    deserializedEvents.push(deserializedEvent);
                }
            }
            return deserializedEvents;
        default:
            return [];
    }
}
/**
 * Deserializes a list of {@linkcode ContractTraceEvent} into a list of CIS-4 events.
 * This function filters out any custom events.
 *
 * @param {ContractTraceEvent[]} events - The list of contract trace events to deserialize
 *
 * @returns {CIS4.NonCustomEvent[]} The deserialized CIS-4 events
 */
function deserializeCIS4ContractTraceEvents(events) {
    const deserializedEvents = [];
    for (const traceEvent of events) {
        if (!('events' in traceEvent)) {
            continue;
        }
        for (const event of traceEvent.events) {
            const deserializedEvent = deserializeCIS4Event(event);
            if (deserializedEvent.type !== CIS4.EventType.Custom) {
                deserializedEvents.push(deserializedEvent);
            }
        }
    }
    return deserializedEvents;
}
//# sourceMappingURL=util.js.map