import { Buffer } from 'buffer/index.js';
import type { CIS2 } from '../cis2/util.js';
import { Cursor } from '../deserializationHelpers.js';
import { OptionJson } from '../schemaTypes.js';
import { type BlockItemSummary, type HexString, type InvokeContractSuccessResult } from '../types.js';
import * as ContractAddress from '../types/ContractAddress.js';
import * as ContractEvent from '../types/ContractEvent.js';
import * as EntrypointName from '../types/EntrypointName.js';
import * as Timestamp from '../types/Timestamp.js';
/** Holds all types related to CIS4 */
export declare namespace CIS4 {
    /** Structure holding an url pointing to some metadata, including an optional checksum */
    type MetadataUrl = CIS2.MetadataUrl;
    /** Structure holding an url pointing to some metadata, including an optional checksum */
    type SchemaRef = MetadataUrl;
    /** Response type for `registryMetadata` query */
    type MetadataResponse = {
        /** URL for issuer metadata */
        issuerMetadata: MetadataUrl;
        /** The credential type */
        credentialType: string;
        /** URL for the credential schema */
        credentialSchema: SchemaRef;
    };
    /** Holds info pertaining to a credential. */
    type CredentialInfo = {
        /** Ed25519 public key of credential holder (hex encoded) */
        holderPubKey: HexString;
        /** Whether holder can revoke or not */
        holderRevocable: boolean;
        /** Time the credential is valid from */
        validFrom: Timestamp.Type;
        /** (Optional) time the credential is valid until */
        validUntil?: Timestamp.Type;
        /** Metadata url of the credential */
        metadataUrl: MetadataUrl;
    };
    /** Response to a credential data query. */
    type CredentialEntry = {
        /** Info for the credential entry */
        credentialInfo: CredentialInfo;
        /** A schema URL or DID address pointing to the JSON schema for a verifiable credential */
        schemaRef: SchemaRef;
        /**
         * The nonce is used to avoid replay attacks when checking the holder's
         * signature on a revocation message. This is the nonce that should be used
         * when signing a revocation.
         */
        revocationNonce: bigint;
    };
    /** Response type for `credentialStatus` query */
    enum CredentialStatus {
        /** The credential is active */
        Active = 0,
        /** The credential has been revoked */
        Revoked = 1,
        /** The credential has expired */
        Expired = 2,
        /** The credential has not been activated */
        NotActivated = 3
    }
    /** A revocation key and its corresponding nonce */
    type RevocationKeyWithNonce = {
        /** The revocation key (hex encoded) */
        key: HexString;
        /** The nonce of the revocation key */
        nonce: bigint;
    };
    /** Data needed for the `registerCredential` update */
    type RegisterCredentialParam = {
        /** The credential info to register */
        credInfo: CredentialInfo;
        /** Any additional data to include in the parameter (hex encoded) */
        additionalData: HexString;
    };
    /** schema serializable JSON representation of parameter for the "registerCredential" entrypoint */
    type RegisterCredentialParamJson = {
        /** The credential info to register */
        credential_info: {
            /** Ed25519 public key of credential holder (hex encoded) */
            holder_id: HexString;
            /** Whether holder can revoke or not */
            holder_revocable: boolean;
            /** Time (as ISO string) the credential is valid from */
            valid_from: Timestamp.SchemaValue;
            /** (Optional) Time (as ISO string) the credential is valid until */
            valid_until: OptionJson<Timestamp.SchemaValue>;
            /** Metadata url of the credential */
            metadata_url: {
                /** The url */
                url: string;
                /** An optional checksum of the data at the URL destination */
                hash: OptionJson<HexString>;
            };
        };
        /** Any additional data to include in the parameter (hex encoded) */
        auxiliary_data: number[];
    };
    /** Data needed for the `revokeCredentialIssuer` update */
    type RevokeCredentialIssuerParam = {
        /** The public key of the credential holder (hex encoded) */
        credHolderPubKey: HexString;
        /** An optional reason for the revocation */
        reason?: string;
        /** Any additional data to include in the parameter (hex encoded) */
        additionalData: HexString;
    };
    /** schema serializable JSON representation of a revocation reason */
    type RevocationReasonJson = {
        /** The reason for revocation */
        reason: string;
    };
    /** schema serializable JSON representation of parameter for the "revokeCredentialIssuer" entrypoint */
    type RevokeCredentialIssuerParamJson = {
        /** The public key of the credential holder (hex encoded) */
        credential_id: HexString;
        /** An optional reason for the revocation */
        reason: OptionJson<RevocationReasonJson>;
        /** Any additional data to include in the parameter (hex encoded) */
        auxiliary_data: number[];
    };
    /** Signing metadata for credential revocation */
    type SigningData = {
        /** The contract address of the CIS4 contract */
        contractAddress: ContractAddress.Type;
        /** The CIS4 entrypoint from which the revocation is done */
        entrypoint: EntrypointName.Type;
        /** The credential nonce */
        nonce: bigint;
        /** Timestamp at which the revocation should be invalidated */
        timestamp: Timestamp.Type;
    };
    type SigningDataJson = {
        /** The contract address of the CIS4 contract */
        contract_address: {
            /** The contract index */
            index: number;
            /** The contract subindex */
            subindex: number;
        };
        /** The CIS4 entrypoint from which the revocation is done */
        entry_point: string;
        /** The credential nonce */
        nonce: number;
        /** Timestamp at which the revocation should be invalidated */
        timestamp: string;
    };
    /** Revocation data for revocations done by the credential holder */
    type RevocationDataHolder = {
        /** The public key of the credential to revoke (hex encoded) */
        credentialPubKey: HexString;
        /** The signing metadata of the revocation */
        signingData: SigningData;
        /** An optional reason for the revocation */
        reason?: string;
    };
    /** Data needed for the `revokeCredentialHolder` update */
    type RevokeCredentialHolderParam = {
        /** Signature on the `data` (hex encoded) */
        signature: HexString;
        /** The revocation data */
        data: RevocationDataHolder;
    };
    /** schema serializable JSON representation of parameter for the "revokeCredentialHolder" entrypoint */
    type RevokeCredentialHolderParamJson = {
        /** Signature on the `data` (hex encoded) */
        signature: HexString;
        /** The revocation data */
        data: {
            /** The public key of the credential to revoke (hex encoded) */
            credential_id: HexString;
            /** The signing metadata of the revocation */
            signing_data: SigningDataJson;
            /** An optional reason for the revocation */
            reason: OptionJson<RevocationReasonJson>;
        };
    };
    /** Revocation data for revocations done by other revocation entities */
    type RevocationDataOther = {
        /** The public key of the credential to revoke (hex encoded) */
        credentialPubKey: HexString;
        /** The data signed */
        signingData: SigningData;
        /** The public key of the revoker (hex encoded) */
        revocationPubKey: HexString;
        /** An optional reason for the revocation */
        reason?: string;
    };
    /** Data needed for the `revokeCredentialOther` update */
    type RevokeCredentialOtherParam = {
        /** Signature on the `data` (hex encoded) */
        signature: HexString;
        /** The revocation data */
        data: RevocationDataOther;
    };
    /** schema serializable JSON representation of parameter for the "revokeCredentialOther" entrypoint */
    type RevokeCredentialOtherParamJson = {
        /** Signature on the `data` (hex encoded) */
        signature: HexString;
        /** The revocation data */
        data: {
            /** The public key of the credential to revoke (hex encoded) */
            credential_id: HexString;
            /** The signing metadata of the revocation */
            signing_data: SigningDataJson;
            /** The public key of the revoker (hex encoded) */
            revocation_key: HexString;
            /** An optional reason for the revocation */
            reason: OptionJson<RevocationReasonJson>;
        };
    };
    /** Data needed for the `registerRevocationKeys` and `removeRevocationKeys` update */
    type UpdateRevocationKeysParam = {
        /** The keys to register/remove */
        keys: HexString[];
        /** Any additional data to include in the parameter (hex encoded) */
        additionalData: HexString;
    };
    /** schema serializable JSON representation of parameter for the "revokeCredentialIssuer" entrypoint */
    type UpdateRevocationKeysParamJson = {
        /** The keys to register/remove */
        keys: HexString[];
        /** Any additional data to include in the parameter (hex encoded) */
        auxiliary_data: number[];
    };
    /** A type of credential revoker. Either the issuer of the credential,
     * holder of the credential, or a third party authority. */
    enum RevokerType {
        /** The issuer of the credential */
        Issuer = 0,
        /** The holder of the credential */
        Holder = 1,
        /** A third party credential authority */
        Other = 2
    }
    /** A revoker of a credential */
    type Revoker = {
        /** The type of revoker */
        type: RevokerType.Issuer | RevokerType.Holder;
    } | {
        /** The type of revoker */
        type: RevokerType.Other;
        /** The public key of the third party credential revoker (hex encoded) */
        key: HexString;
    };
    /** An action determining if a revocation key is registered or removed */
    enum RevocationKeyAction {
        /** Register a revocation key */
        Register = 0,
        /** Remove a revocation key */
        Remove = 1
    }
    /** A type of CIS-4 event */
    enum EventType {
        /** A credential was registered */
        RegisterCredential = 0,
        /** A credential was revoked */
        RevokeCredential = 1,
        /** The issuer metadata was updated */
        IssuerMetadata = 2,
        /** The credential metadata was updated */
        CredentialMetadata = 3,
        /** The credential schema reference was updated */
        CredentialSchemaRef = 4,
        /** A revocation key was registered or removed */
        RevocationKey = 5,
        /** A custom event outside CIS-4 */
        Custom = 6
    }
    /** A RegisterCredential event from the CIS-4 standard */
    type RegisterCredentialEvent = {
        /** The type of the event */
        type: EventType.RegisterCredential;
        /** The public key of the registered credential (hex encoded) */
        credentialPubKey: HexString;
        /** The schema reference of the registered credential */
        schemaRef: SchemaRef;
        /** The credential type of the registered credential */
        credentialType: string;
        /** The metadata URL of the registered credential */
        metadataUrl: MetadataUrl;
    };
    /** A RevokeCredential event from the CIS-4 standard */
    type RevokeCredentialEvent = {
        /** The type of the event */
        type: EventType.RevokeCredential;
        /** The public key of the revoked credential (hex encoded) */
        credentialPubKey: HexString;
        /** The revoker that revoked the credential */
        revoker: Revoker;
        /** An optional reason for the revocation */
        reason?: string;
    };
    /** An IssuerMetadata event from the CIS-4 standard */
    type IssuerMetadataEvent = {
        /** The type of the event */
        type: EventType.IssuerMetadata;
        /** The updated metadata URL of the issuer */
        metadataUrl: MetadataUrl;
    };
    /** A CredentialMetadata event from the CIS-4 standard */
    type CredentialMetadataEvent = {
        /** The type of the event */
        type: EventType.CredentialMetadata;
        /** The public key of the credential (hex encoded) */
        credentialPubKey: HexString;
        /** The updated metadata URL of the credential */
        metadataUrl: MetadataUrl;
    };
    /** A CredentialSchemaRef event from the CIS-4 standard */
    type CredentialSchemaRefEvent = {
        /** The type of the event */
        type: EventType.CredentialSchemaRef;
        /** The credential type of the credential */
        credentialType: string;
        /** The updated schema reference of the credential */
        schemaRef: SchemaRef;
    };
    /** A RevocationKey event from the CIS-4 standard */
    type RevocationKeyEvent = {
        /** The type of the event */
        type: EventType.RevocationKey;
        /** The key being registered or removed */
        key: HexString;
        /** The action (either registration or removal) performed on the revocation key */
        action: RevocationKeyAction;
    };
    /** A custom event outside CIS-4 */
    type CustomEvent = {
        /** The type of the event */
        type: EventType.Custom;
        /** The raw data of the event */
        data: Uint8Array;
    };
    /** A CIS-4 event */
    type Event = RegisterCredentialEvent | RevokeCredentialEvent | IssuerMetadataEvent | CredentialMetadataEvent | CredentialSchemaRefEvent | RevocationKeyEvent | CustomEvent;
    /** A CIS-4 event which is not a custom event */
    type NonCustomEvent = Exclude<Event, CustomEvent>;
}
/**
 * A wrapper around an ed25519 keypair which is used by {@link CIS4Contract} methods for signing as various entities.
 */
export declare class Web3IdSigner {
    private privateKey;
    private publicKey;
    /**
     * Builds a `Web3IdSigner` from ed25519 keypair
     *
     * @param {HexString} privateKey - the ed25519 private key used for signing
     * @param {HexString} publicKey - the ed25519 public key used for verifcation of signature
     */
    constructor(privateKey: HexString, publicKey: HexString);
    /**
     * Builds a `Web3IdSigner` from ed25519 private key
     *
     * @param {HexString} privateKey - the ed25519 private key used for signing
     *
     * @returns {Web3IdSigner} signer structure.
     */
    static from(privateKey: HexString): Promise<Web3IdSigner>;
    /** Public key of signer */
    get pubKey(): HexString;
    /**
     * Signs the message given
     *
     * @param {ArrayBuffer} message - the message to sign
     *
     * @returns {Buffer} the signature on `message`
     */
    sign(message: ArrayBuffer): Promise<Buffer>;
}
/**
 * Expected prefix of messages signed for CIS4 revocation entrypoints.
 */
export declare const REVOKE_DOMAIN: Buffer;
export declare function serializeDate(date: Timestamp.Type): Buffer;
export declare function deserializeDate(cursor: Cursor): Timestamp.Type;
/**
 * Serializes {@link CIS4.RegisterCredentialParam} into bytes which can be
 * supplied as parameters to `registerCredential` entrypoints on CIS4 contracts
 *
 * @param {CIS4.RegisterCredentialParam} param - The parameters to serialize
 *
 * @returns {Buffer} the parameters serialized to bytes
 */
export declare function serializeCIS4RegisterCredentialParam(param: CIS4.RegisterCredentialParam): Buffer;
/**
 * Attemps to deserializes a value into {@link CIS4.CredentialEntry}
 *
 * @param {HexString} value - The value (hex encoded) to deserialize
 *
 * @throws If deserialization fails
 *
 * @returns {CIS4.CredentialEntry} The credential entry
 */
export declare function deserializeCIS4CredentialEntry(value: HexString): CIS4.CredentialEntry;
/**
 * Attemps to deserializes a value into {@link CIS4.CredentialStatus}
 *
 * @param {HexString} value - The value (hex encoded) to deserialize
 *
 * @throws If deserialization fails
 *
 * @returns {CIS4.CredentialStatus} The credential status
 */
export declare function deserializeCIS4CredentialStatus(value: HexString): CIS4.CredentialStatus;
/**
 * Attemps to deserializes a value into a list of {@link CIS4.RevocationKeyWithNonce}
 *
 * @param {HexString} value - The value (hex encoded) to deserialize
 *
 * @throws If deserialization fails
 *
 * @returns {CIS4.RevocationKeyWithNonce[]} The revocation keys
 */
export declare const deserializeCIS4RevocationKeys: (value: string) => CIS4.RevocationKeyWithNonce[];
/**
 * Format {@link CIS4.RegisterCredentialParam} as JSON compatible with serialization with corresponding schema.
 */
export declare function formatCIS4RegisterCredential({ credInfo, additionalData, }: CIS4.RegisterCredentialParam): CIS4.RegisterCredentialParamJson;
/**
 * Serializes {@link CIS4.RevokeCredentialIssuerParam} into bytes which can be
 * supplied as parameters to `revokeCredentialIssuer` entrypoints on CIS4 contracts
 *
 * @param {CIS4.RevokeCredentialIssuerParam} param - The parameters to serialize
 *
 * @returns {Buffer} the parameters serialized to bytes
 */
export declare function serializeCIS4RevokeCredentialIssuerParam(param: CIS4.RevokeCredentialIssuerParam): Buffer;
/**
 * Format {@link CIS4.RevokeCredentialIssuerParam} as JSON compatible with serialization with corresponding schema.
 */
export declare function formatCIS4RevokeCredentialIssuer({ credHolderPubKey, reason, additionalData, }: CIS4.RevokeCredentialIssuerParam): CIS4.RevokeCredentialIssuerParamJson;
/**
 * Serializes {@link CIS4.RevocationDataHolder} into bytes which can be
 * supplied as parameters to `revokeCredentialHolder` entrypoints on CIS4 contracts prefixed
 * with a signature on the data
 *
 * @param {CIS4.RevocationDataHolder} data - The data to serialize
 *
 * @returns {Buffer} the data serialized to bytes
 */
export declare function serializeCIS4RevocationDataHolder(data: CIS4.RevocationDataHolder): Buffer;
/**
 * Format {@link CIS4.RevokeCredentialHolderParam} as JSON compatible with serialization with corresponding schema.
 */
export declare function formatCIS4RevokeCredentialHolder({ signature, data, }: CIS4.RevokeCredentialHolderParam): CIS4.RevokeCredentialHolderParamJson;
/**
 * Serializes {@link CIS4.RevocationDataOther} into bytes which can be
 * supplied as parameters to `revokeCredentialOther` entrypoints on CIS4 contracts prefixed
 * with a signature on the data
 *
 * @param {CIS4.RevocationDataOther} data - The data to serialize
 *
 * @returns {Buffer} the data serialized to bytes
 */
export declare function serializeCIS4RevocationDataOther(data: CIS4.RevocationDataOther): Buffer;
/**
 * Format {@link CIS4.RevokeCredentialOtherParam} as JSON compatible with serialization with corresponding schema.
 */
export declare function formatCIS4RevokeCredentialOther({ signature, data, }: CIS4.RevokeCredentialOtherParam): CIS4.RevokeCredentialOtherParamJson;
/**
 * Serializes {@link CIS4.UpdateRevocationKeysParam} into bytes which can be
 * supplied as parameters to `registerRevocationKeys` and `removeRevocationKeys`
 * entrypoints on CIS4 contracts
 *
 * @param {CIS4.RevokeCredentialIssuerParam} param - The parameters to serialize
 *
 * @returns {Buffer} the parameters serialized to bytes
 */
export declare function serializeCIS4UpdateRevocationKeysParam(param: CIS4.UpdateRevocationKeysParam): Buffer;
/**
 * Format {@link CIS4.UpdateRevocationKeysParam} as JSON compatible with serialization with corresponding schema.
 */
export declare function formatCIS4UpdateRevocationKeys({ keys, additionalData, }: CIS4.UpdateRevocationKeysParam): CIS4.UpdateRevocationKeysParamJson;
/**
 * Attemps to deserializes a value into a list of {@link CIS4.MetadataResponse}
 *
 * @param {HexString} value - The value (hex encoded) to deserialize
 *
 * @throws If deserialization fails
 *
 * @returns {CIS4.MetadataResponse} The metadata
 */
export declare function deserializeCIS4MetadataResponse(value: HexString): CIS4.MetadataResponse;
/**
 * Deserializes a CIS-4 event according to the CIS-4 standard.
 *
 * @param {ContractEvent.Type} event - The event to deserialize
 *
 * @returns {CIS4.Event} The deserialized event
 *
 * @throws If the event is not custom (starts with an unreserved tag)
 * and the event cannot be deserialized to a valid CIS-4 event
 */
export declare function deserializeCIS4Event(event: ContractEvent.Type): CIS4.Event;
/**
 * Deserializes a successful contract invokation to a list of all CIS-4 events
 * (skipping custom events) according to the CIS-4 standard.
 *
 * @param {InvokeContractSuccessResult} result - The contract invokation result to deserialize
 *
 * @returns {CIS4.NonCustomEvent[]} The deserialized events
 */
export declare function deserializeCIS4EventsFromInvokationResult(result: InvokeContractSuccessResult): CIS4.NonCustomEvent[];
/**
 * Deserializes all CIS-4 events (skipping custom events) from a {@linkcode BlockItemSummary}.
 *
 * @param {BlockItemSummary} summary - The summary to deserialize
 *
 * @returns {CIS4.NonCustomEvent[]} The deserialized events
 */
export declare function deserializeCIS4EventsFromSummary(summary: BlockItemSummary): CIS4.NonCustomEvent[];
