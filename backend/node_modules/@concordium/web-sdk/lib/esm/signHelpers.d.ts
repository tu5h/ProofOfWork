import { Buffer } from 'buffer/index.js';
import { AccountInfo, AccountTransaction, AccountTransactionSignature, Base58String, HexString, JsonString } from './types.js';
import * as AccountAddress from './types/AccountAddress.js';
export interface KeyPair {
    signKey: HexString;
    verifyKey: HexString;
}
export interface CredentialKeys {
    keys: Record<number, KeyPair>;
    threshold: number;
}
export interface AccountKeys {
    keys: Record<number, CredentialKeys>;
    threshold: number;
}
export type SimpleAccountKeys = Record<number, Record<number, HexString>>;
export interface WithAccountKeys {
    accountKeys: AccountKeys;
}
export interface WalletExportFormat {
    type: string;
    v: number;
    environment: string;
    value: {
        accountKeys: AccountKeys;
        address: Base58String;
        credentials: Record<number, HexString>;
    };
}
/**
 * Parses a wallet export file into a WalletExportFormat. The wallet export
 * file is exported from a concordium wallet.
 */
export declare function parseWallet(walletString: JsonString): WalletExportFormat;
/**
 * A structure to use for creating signatures on a given digest.
 */
export interface AccountSigner {
    /**
     * Creates a signature of the provided digest
     *
     * @param {ArrayBuffer} digest - The digest to create signatures on.
     *
     * @returns {Promise<AccountTransactionSignature>} A promise resolving with a set of signatures for a set of credentials corresponding to some account
     */
    sign(digest: ArrayBuffer): Promise<AccountTransactionSignature>;
    /**
     * Returns the amount of signatures that the signer produces
     */ getSignatureCount(): bigint;
}
/**
 * Gets Ed25519 signature for `digest`.
 *
 * @param {ArrayBuffer} digest - the message to sign.
 * @param {HexString} privateKey - the ed25519 private key in HEX format.
 *
 * @returns {Buffer} the signature.
 */
export declare const getSignature: (digest: ArrayBuffer, privateKey: HexString) => Promise<Buffer>;
/**
 * Creates an `AccountSigner` for an account which uses the first credential's first keypair.
 * Note that if the account has a threshold > 1 or the first credentials has a threshold > 1, the transaction signed using this will fail.
 *
 * @param {HexString} privateKey - the ed25519 private key in HEX format. (First credential's first keypair's private key)
 *
 * @returns {AccountSigner} an `AccountSigner` which creates a signature using the first credentials first keypair
 */
export declare function buildBasicAccountSigner(privateKey: HexString): AccountSigner;
/**
 * Creates an `AccountSigner` for an account exported from a Concordium wallet.
 * Creating signatures using the `AccountSigner` will hold signatures for all credentials and all their respective keys included in the export.
 *
 * @param {WalletExportFormat} walletExport - The wallet export object.
 *
 * @returns {AccountSigner} An `AccountSigner` which creates signatures using all keys for all credentials
 */
export declare function buildAccountSigner(walletExport: WalletExportFormat): AccountSigner;
/**
 * Creates an `AccountSigner` for an arbitrary format extending the {@link WithAccountKeys} type.
 * Creating signatures using the `AccountSigner` will hold signatures for all credentials and all their respective keys included.
 *
 * @param {AccountKeys} value.accountKeys - Account keys of type {@link AccountKeys} to use for creating signatures
 *
 * @returns {AccountSigner} An `AccountSigner` which creates signatures using all keys for all credentials
 */
export declare function buildAccountSigner<T extends WithAccountKeys>(value: T): AccountSigner;
/**
 * Creates an `AccountSigner` for the {@link SimpleAccountKeys} type.
 * Creating signatures using the `AccountSigner` will hold signatures for all credentials and all their respective keys included.
 *
 * @param {SimpleAccountKeys} keys - Account keys to use for creating signatures
 *
 * @returns {AccountSigner} An `AccountSigner` which creates signatures using all keys for all credentials
 */
export declare function buildAccountSigner(keys: SimpleAccountKeys): AccountSigner;
/**
 * Creates an `AccountSigner` for an account which uses the first credential's first keypair.
 * Note that if the account has a threshold > 1 or the first credentials has a threshold > 1, the transaction signed using this will fail.
 *
 * @param {HexString} key - The ed25519 private key in HEX format. (First credential's first keypair's private key)
 *
 * @returns {AccountSigner} An `AccountSigner` which creates a signature using the first credentials first keypair
 */
export declare function buildAccountSigner(key: HexString): AccountSigner;
/**
 * Helper function to sign an AccountTransaction.
 * @param transaction the account transaction to sign
 * @param signer An object that handles the keys of the account, and performs the actual signing.
 */
export declare function signTransaction(transaction: AccountTransaction, signer: AccountSigner): Promise<AccountTransactionSignature>;
/**
 * Helper function to sign a message.
 * Note that this function prepends the account address (32 bytes) and 8 zero-bytes to ensure that the message is not a transaction.
 * Note that the current prepend is temporary and will later be replaced.
 * @param message the message to sign, assumed to be utf8 encoded string or a Uint8Array/buffer.
 * @param signer An object that handles the keys of the account, and performs the actual signing.
 */
export declare function signMessage(account: AccountAddress.Type, message: string | Uint8Array, signer: AccountSigner): Promise<AccountTransactionSignature>;
/**
 * Helper function to verify a signed message.
 * @param message the message to sign, assumed to be utf8 encoded string or a Uint8Array/buffer.
 * @param signature the signature of a message, from a specific account.
 * @param accountInfo the address and credentials of the account
 */
export declare function verifyMessageSignature(message: string | Uint8Array, signature: AccountTransactionSignature, accountInfo: Pick<AccountInfo, 'accountThreshold' | 'accountCredentials' | 'accountAddress'>): Promise<boolean>;
