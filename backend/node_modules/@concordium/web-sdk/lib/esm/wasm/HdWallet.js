import * as wasm from '@concordium/rust-bindings/wallet';
import { mnemonicToSeedSync, validateMnemonic } from '@scure/bip39';
import { wordlist } from '@scure/bip39/wordlists/english';
import { Buffer } from 'buffer/index.js';
import { isHex } from '../util.js';
/**
 * Class for Hierarchical Deterministic key derivation for Concordium identities and accounts.
 */
export class ConcordiumHdWallet {
    static fromSeedPhrase(seedPhrase, network) {
        if (!validateMnemonic(seedPhrase, wordlist)) {
            throw new Error('Invalid seed phrase.');
        }
        const seedAsHex = Buffer.from(mnemonicToSeedSync(seedPhrase)).toString('hex');
        return new ConcordiumHdWallet(seedAsHex, network);
    }
    static fromHex(seedAsHex, network) {
        if (seedAsHex.length !== 128) {
            throw new Error('The provided seed ' + seedAsHex + ' is invalid as its length was not 128');
        }
        if (!isHex(seedAsHex)) {
            throw new Error('The provided seed ' + seedAsHex + ' does not represent a hexidecimal value');
        }
        return new ConcordiumHdWallet(seedAsHex, network);
    }
    constructor(seedAsHex, network) {
        this.seedAsHex = seedAsHex;
        this.network = network;
    }
    getAccountSigningKey(identityProviderIndex, identityIndex, credentialCounter) {
        return Buffer.from(wasm.getAccountSigningKey(this.seedAsHex, this.network, identityProviderIndex, identityIndex, credentialCounter), 'hex');
    }
    getAccountPublicKey(identityProviderIndex, identityIndex, credentialCounter) {
        return Buffer.from(wasm.getAccountPublicKey(this.seedAsHex, this.network, identityProviderIndex, identityIndex, credentialCounter), 'hex');
    }
    getCredentialId(identityProviderIndex, identityIndex, credentialCounter, { onChainCommitmentKey }) {
        return Buffer.from(wasm.getCredentialId(this.seedAsHex, this.network, identityProviderIndex, identityIndex, credentialCounter, onChainCommitmentKey), 'hex');
    }
    getPrfKey(identityProviderIndex, identityIndex) {
        return Buffer.from(wasm.getPrfKey(this.seedAsHex, this.network, identityProviderIndex, identityIndex), 'hex');
    }
    getIdCredSec(identityProviderIndex, identityIndex) {
        return Buffer.from(wasm.getIdCredSec(this.seedAsHex, this.network, identityProviderIndex, identityIndex), 'hex');
    }
    getSignatureBlindingRandomness(identityProviderIndex, identityIndex) {
        return Buffer.from(wasm.getSignatureBlindingRandomness(this.seedAsHex, this.network, identityProviderIndex, identityIndex), 'hex');
    }
    getAttributeCommitmentRandomness(identityProviderIndex, identityIndex, credentialCounter, attribute) {
        return Buffer.from(wasm.getAttributeCommitmentRandomness(this.seedAsHex, this.network, identityProviderIndex, identityIndex, credentialCounter, attribute), 'hex');
    }
    getVerifiableCredentialSigningKey(issuer, verifiableCredentialIndex) {
        return Buffer.from(wasm.getVerifiableCredentialSigningKey(this.seedAsHex, this.network, issuer.index, issuer.subindex, verifiableCredentialIndex), 'hex');
    }
    getVerifiableCredentialPublicKey(issuer, verifiableCredentialIndex) {
        return Buffer.from(wasm.getVerifiableCredentialPublicKey(this.seedAsHex, this.network, issuer.index, issuer.subindex, verifiableCredentialIndex), 'hex');
    }
    getVerifiableCredentialBackupEncryptionKey() {
        return Buffer.from(wasm.getVerifiableCredentialBackupEncryptionKey(this.seedAsHex, this.network), 'hex');
    }
}
//# sourceMappingURL=HdWallet.js.map