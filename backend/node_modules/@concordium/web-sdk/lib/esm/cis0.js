import { Buffer } from 'buffer/index.js';
import { stringify } from 'json-bigint';
import { makeDeserializeListResponse } from './deserializationHelpers.js';
import { encodeWord16, packBufferWithWord8Length } from './serializationHelpers.js';
import * as ContractAddress from './types/ContractAddress.js';
import * as ContractName from './types/ContractName.js';
import * as EntrypointName from './types/EntrypointName.js';
import * as Parameter from './types/Parameter.js';
import * as ReceiveName from './types/ReceiveName.js';
import * as ReturnValue from './types/ReturnValue.js';
import { makeDynamicFunction } from './util.js';
/**
 * Namespace with types for CIS-0 standard contracts
 */
// eslint-disable-next-line @typescript-eslint/no-namespace
export var CIS0;
(function (CIS0) {
    /** Possible response types for a query */
    let SupportType;
    (function (SupportType) {
        /** The standard is not supported */
        SupportType[SupportType["NoSupport"] = 0] = "NoSupport";
        /** The standard is supported */
        SupportType[SupportType["Support"] = 1] = "Support";
        /** The standard is supported by another contract */
        SupportType[SupportType["SupportBy"] = 2] = "SupportBy";
    })(SupportType = CIS0.SupportType || (CIS0.SupportType = {}));
})(CIS0 || (CIS0 = {}));
function serializeSupportIdentifier(id) {
    const buf = Buffer.from(id, 'ascii');
    return packBufferWithWord8Length(buf);
}
function serializeSupportIdentifiers(ids) {
    const n = encodeWord16(ids.length, true);
    return Buffer.concat([n, ...ids.map(serializeSupportIdentifier)]);
}
const deserializeSupportResult = makeDeserializeListResponse((cursor) => {
    const type = cursor.read(1).readUInt8(0);
    if (type > 2) {
        throw new Error('Unsupported support result type');
    }
    if (type !== CIS0.SupportType.SupportBy) {
        return { type };
    }
    const numAddresses = cursor.read(1).readUInt8(0);
    const addresses = [];
    for (let i = 0; i < numAddresses; i++) {
        const index = cursor.read(8).readBigUInt64LE(0).valueOf();
        const subindex = cursor.read(8).readBigUInt64LE(0).valueOf();
        addresses.push(ContractAddress.create(index, subindex));
    }
    return {
        type,
        addresses,
    };
});
export async function cis0Supports(grpcClient, contractAddress, standardIds, blockHash) {
    const instanceInfo = await grpcClient.getInstanceInfo(contractAddress).catch((e) => {
        throw new Error(`Could not get contract instance info for contract at address ${stringify(contractAddress)}: ${e.message ?? e}`);
    });
    const contractName = ContractName.fromInitName(instanceInfo.name);
    const supportReceiveName = ReceiveName.create(contractName, EntrypointName.fromStringUnchecked('supports'));
    if (!instanceInfo.methods.some((methods) => ReceiveName.equals(methods, supportReceiveName))) {
        return undefined;
    }
    const parameter = Parameter.fromBuffer(makeDynamicFunction(serializeSupportIdentifiers)(standardIds));
    const response = await grpcClient.invokeContract({
        contract: contractAddress,
        parameter,
        method: supportReceiveName,
    }, blockHash);
    if (response === undefined || response.tag === 'failure' || response.returnValue === undefined) {
        throw new Error(`Failed to invoke support for contract at ${stringify(contractAddress)}${response.tag === 'failure' && ` with error ${stringify(response.reason)}`}`);
    }
    const results = deserializeSupportResult(ReturnValue.toHexString(response.returnValue));
    const isListInput = Array.isArray(standardIds);
    const expectedValuesLength = isListInput ? standardIds.length : 1;
    if (results.length !== expectedValuesLength) {
        throw new Error('Mismatch between length of queries in request and values in response.');
    }
    if (isListInput) {
        return results;
    }
    else {
        return results[0];
    }
}
//# sourceMappingURL=cis0.js.map