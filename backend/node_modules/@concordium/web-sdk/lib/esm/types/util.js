/**
 * Discriminator for {@linkcode TypedJson}. The member used to identify each type is
 * exported from each type module and can be accessed through named export `JSON_DISCRIMINATOR`.
 */
export var TypedJsonDiscriminator;
(function (TypedJsonDiscriminator) {
    TypedJsonDiscriminator["AccountAddress"] = "ccd_account_address";
    TypedJsonDiscriminator["BlockHash"] = "ccd_block_hash";
    TypedJsonDiscriminator["CcdAmount"] = "ccd_ccd_amount";
    TypedJsonDiscriminator["ContractAddress"] = "ccd_contract_address";
    TypedJsonDiscriminator["ContractName"] = "ccd_contract_name";
    TypedJsonDiscriminator["CredentialRegistrationId"] = "ccd_cred_reg_id";
    TypedJsonDiscriminator["DataBlob"] = "ccd_data_blob";
    TypedJsonDiscriminator["Duration"] = "ccd_duration";
    TypedJsonDiscriminator["Energy"] = "ccd_energy";
    TypedJsonDiscriminator["EntrypointName"] = "ccd_entrypoint_name";
    TypedJsonDiscriminator["InitName"] = "ccd_init_name";
    TypedJsonDiscriminator["ModuleReference"] = "ccd_module_reference";
    TypedJsonDiscriminator["Parameter"] = "ccd_parameter";
    TypedJsonDiscriminator["ReceiveName"] = "ccd_receive_name";
    TypedJsonDiscriminator["ReturnValue"] = "ccd_return_value";
    TypedJsonDiscriminator["SequenceNumber"] = "ccd_sequence_number";
    TypedJsonDiscriminator["Timestamp"] = "ccd_timestamp";
    TypedJsonDiscriminator["TransactionExpiry"] = "ccd_transaction_expiry";
    TypedJsonDiscriminator["TransactionHash"] = "ccd_transaction_hash";
})(TypedJsonDiscriminator || (TypedJsonDiscriminator = {}));
/**
 * Type predeicate for {@linkcode TypedJson}.
 *
 * @param value value to test
 * @returns boolean indicating whether `value` is {@linkcode TypedJson}
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function isTypedJsonCandidate(value) {
    if (typeof value !== 'object' || value === null) {
        return false;
    }
    return ['@type', 'value'].every((name) => Object.getOwnPropertyNames(value).includes(name));
}
/**
 * Describes the type of the JsonParseError.
 */
export var TypedJsonParseErrorCode;
(function (TypedJsonParseErrorCode) {
    /** Malformed JSON passed to parser function */
    TypedJsonParseErrorCode["MALFORMED"] = "MALFORMED";
    /** JSON passed to parser function had unexpected {@linkcode TypedJsonDiscriminator} type discriminator */
    TypedJsonParseErrorCode["WRONG_TYPE"] = "WRONG_TYPE";
    /** Value could not be parsed successfully */
    TypedJsonParseErrorCode["INVALID_VALUE"] = "INVALID_VALUE";
})(TypedJsonParseErrorCode || (TypedJsonParseErrorCode = {}));
/**
 * Error thrown from trying to parse objects of type {@linkcode TypedJson}
 */
export class TypedJsonParseError extends Error {
    /**
     * @param {string} message - The error message.
     */
    constructor(message) {
        super(message);
        this._name = 'TypedJsonParseError';
    }
    get name() {
        return `${this._name}.${this.code}`;
    }
}
export class TypedJsonMalformedError extends TypedJsonParseError {
    constructor() {
        super(...arguments);
        this.code = TypedJsonParseErrorCode.MALFORMED;
    }
}
export class TypedJsonWrongTypeError extends TypedJsonParseError {
    /**
     * @param {TypedJsonDiscriminator} expected - The discriminator expected by the typed JSON parser.
     * @param {TypedJsonDiscriminator} actual - The discriminator received by the typed JSON parser.
     */
    constructor(expected, actual) {
        super(`Wrong type discriminator found in JSON. Expected "${expected}", found "${actual}"`);
        this.expected = expected;
        this.actual = actual;
        this.code = TypedJsonParseErrorCode.WRONG_TYPE;
    }
}
export class TypedJsonInvalidValueError extends TypedJsonParseError {
    /**
     * @param {string} inner - The original cause of the error.
     */
    constructor(inner) {
        super(`Unable to parse value (${inner?.message ?? inner})`);
        this.inner = inner;
        this.code = TypedJsonParseErrorCode.INVALID_VALUE;
        if (inner instanceof Error) {
            this.stack = inner.stack ?? this.stack;
        }
    }
}
/**
 * Creates a function to convert {@linkcode TypedJson} to their corresponding type instance.
 *
 * @template V - The JSON value
 * @template T - The type returned
 *
 * @param {TypedJsonDiscriminator} expectedTypeDiscriminator - The discriminator expected in the JSON string parsed
 * @param {Function} toType - A function converting values of type `V` to instances of type `T`
 *
 * @throws {TypedJsonParseError} {@linkcode TypedJsonParseError} if the returned function fails to parse the passed value.
 *
 * @returns The JSON parser function
 */
export function makeFromTypedJson(expectedTypeDiscriminator, toType) {
    return ({ ['@type']: type, value }) => {
        if (type === undefined || value === undefined) {
            throw new TypedJsonMalformedError('Expected both "@type" and "value" properties to be available in JSON');
        }
        if (expectedTypeDiscriminator !== type) {
            throw new TypedJsonWrongTypeError(expectedTypeDiscriminator, type);
        }
        try {
            return toType(value);
        }
        catch (e) {
            // Value cannot be successfully parsed
            throw new TypedJsonInvalidValueError(value);
        }
    };
}
//# sourceMappingURL=util.js.map