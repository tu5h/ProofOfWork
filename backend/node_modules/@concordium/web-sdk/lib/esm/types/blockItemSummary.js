import { isEqualContractAddress } from '../contractHelpers.js';
import { AccountTransactionType, TransactionSummaryType } from '../types.js';
import { isDefined } from '../util.js';
import * as AccountAddress from './AccountAddress.js';
import { TransactionEventTag, } from './transactionEvent.js';
export var TransactionKindString;
(function (TransactionKindString) {
    TransactionKindString["DeployModule"] = "deployModule";
    TransactionKindString["InitContract"] = "initContract";
    TransactionKindString["Update"] = "update";
    TransactionKindString["Transfer"] = "transfer";
    TransactionKindString["AddBaker"] = "addBaker";
    TransactionKindString["RemoveBaker"] = "removeBaker";
    TransactionKindString["UpdateBakerStake"] = "updateBakerStake";
    TransactionKindString["UpdateBakerRestakeEarnings"] = "updateBakerRestakeEarnings";
    TransactionKindString["UpdateBakerKeys"] = "updateBakerKeys";
    TransactionKindString["UpdateCredentialKeys"] = "updateCredentialKeys";
    TransactionKindString["BakingReward"] = "bakingReward";
    TransactionKindString["BlockReward"] = "blockReward";
    TransactionKindString["FinalizationReward"] = "finalizationReward";
    TransactionKindString["EncryptedAmountTransfer"] = "encryptedAmountTransfer";
    TransactionKindString["TransferToEncrypted"] = "transferToEncrypted";
    TransactionKindString["TransferToPublic"] = "transferToPublic";
    TransactionKindString["TransferWithSchedule"] = "transferWithSchedule";
    TransactionKindString["UpdateCredentials"] = "updateCredentials";
    TransactionKindString["RegisterData"] = "registerData";
    TransactionKindString["TransferWithMemo"] = "transferWithMemo";
    TransactionKindString["EncryptedAmountTransferWithMemo"] = "encryptedAmountTransferWithMemo";
    TransactionKindString["TransferWithScheduleAndMemo"] = "transferWithScheduleAndMemo";
    TransactionKindString["ConfigureBaker"] = "configureBaker";
    TransactionKindString["ConfigureDelegation"] = "configureDelegation";
    TransactionKindString["StakingReward"] = "paydayAccountReward";
    TransactionKindString["Failed"] = "failed";
})(TransactionKindString || (TransactionKindString = {}));
/**
 * Given an AccountTransactionType number value, return the corresponding TransactionKindString value
 */
export function getTransactionKindString(type) {
    return TransactionKindString[AccountTransactionType[type]];
}
/**
 * Type predicate for {@link InitContractSummary}.
 *
 * @param {BlockItemSummary} summary - The block item summary to check.
 *
 * @returns {boolean} whether summary is of type `InitContractSummary`.
 */
export const isInitContractSummary = (summary) => summary.type === TransactionSummaryType.AccountTransaction &&
    summary.transactionType === TransactionKindString.InitContract;
/**
 * Type predicate for {@link UpdateContractSummary}.
 *
 * @param {BlockItemSummary} summary - The block item summary to check.
 *
 * @returns {boolean} whether summary is of type `UpdateContractSummary`.
 */
export const isUpdateContractSummary = (summary) => summary.type === TransactionSummaryType.AccountTransaction &&
    summary.transactionType === TransactionKindString.Update;
/**
 * Type predicate for transfer-like transactions.
 *
 * @param {BlockItemSummary} summary - The block item summary to check.
 *
 * @returns {boolean} whether summary is of type `TransferSummary` or `TransferWithMemoSummary`.
 */
export const isTransferLikeSummary = (summary) => summary.type === TransactionSummaryType.AccountTransaction &&
    (summary.transactionType === TransactionKindString.Transfer ||
        summary.transactionType === TransactionKindString.TransferWithMemo);
/**
 * Type predicate for {@link FailedTransactionSummary}.
 *
 * @param {BlockItemSummary} summary - The block item summary to check.
 *
 * @returns {boolean} whether transaction was rejected.
 */
export const isRejectTransaction = (summary) => summary.type === TransactionSummaryType.AccountTransaction &&
    summary.transactionType === TransactionKindString.Failed;
/**
 * Helper function to determine whether a transaction was successful (inverse of {@link isRejectTransaction}).
 *
 * @param {BlockItemSummary} summary - The block item summary to check.
 *
 * @returns {boolean} whether transaction was successful.
 */
export const isSuccessTransaction = (summary) => !isRejectTransaction(summary);
export function getTransactionRejectReason(summary) {
    if (!isRejectTransaction(summary)) {
        return undefined;
    }
    return summary.rejectReason;
}
export function getReceiverAccount(summary) {
    if (summary.type !== TransactionSummaryType.AccountTransaction) {
        return undefined;
    }
    switch (summary.transactionType) {
        case TransactionKindString.Transfer:
        case TransactionKindString.TransferWithMemo:
        case TransactionKindString.TransferWithScheduleAndMemo:
            return summary.transfer.to;
        case TransactionKindString.TransferWithSchedule:
            return summary.event.to;
    }
}
export function affectedContracts(summary) {
    if (summary.type !== TransactionSummaryType.AccountTransaction) {
        return [];
    }
    switch (summary.transactionType) {
        case TransactionKindString.InitContract: {
            return [summary.contractInitialized.address];
        }
        case TransactionKindString.Update: {
            return summary.events.reduce((addresses, event) => {
                if (event.tag !== TransactionEventTag.Updated ||
                    addresses.some(isEqualContractAddress(event.address))) {
                    return addresses;
                }
                return [...addresses, event.address];
            }, []);
        }
        default: {
            return [];
        }
    }
}
export function affectedAccounts(summary) {
    if (summary.type !== TransactionSummaryType.AccountTransaction) {
        return [];
    }
    switch (summary.transactionType) {
        case TransactionKindString.EncryptedAmountTransfer:
        case TransactionKindString.EncryptedAmountTransferWithMemo:
            return [summary.added.account, summary.removed.account];
        case TransactionKindString.TransferToEncrypted:
            return [summary.added.account];
        case TransactionKindString.TransferToPublic:
            return [summary.removed.account];
        case TransactionKindString.Update: {
            return summary.events.reduce((addresses, event) => {
                if (event.tag === TransactionEventTag.Transferred &&
                    !addresses.some(AccountAddress.equals.bind(undefined, event.to))) {
                    return [...addresses, event.to];
                }
                return addresses;
            }, [summary.sender]);
        }
        default: {
            const receiver = getReceiverAccount(summary);
            if (receiver === undefined || AccountAddress.equals(summary.sender, receiver)) {
                return [summary.sender];
            }
            return [summary.sender, receiver];
        }
    }
}
export function getSummaryContractUpdateLogs(summary) {
    if (summary.type !== TransactionSummaryType.AccountTransaction || !isUpdateContractSummary(summary)) {
        return [];
    }
    return summary.events
        .map((event) => {
        switch (event.tag) {
            case TransactionEventTag.Updated:
            case TransactionEventTag.Interrupted:
                return { address: event.address, events: event.events };
            default:
                return undefined;
        }
    })
        .filter(isDefined);
}
//# sourceMappingURL=blockItemSummary.js.map