import { Buffer } from 'buffer/index.js';
import type { HexString } from '../types.js';
import { TypedJson, TypedJsonDiscriminator } from './util.js';
/**
 * The {@linkcode TypedJsonDiscriminator} discriminator associated with {@linkcode Type} type.
 */
export declare const JSON_DISCRIMINATOR = TypedJsonDiscriminator.DataBlob;
export type Serializable = HexString;
/**
 * Representation of a transfer's memo or a registerData transaction's data, which enforces that:
 * - the byte length is <= 256
 */
export declare class DataBlob {
    readonly data: Buffer;
    /** Having a private field prevents similar structured objects to be considered the same type (similar to nominal typing). */
    private __type;
    constructor(data: ArrayBuffer);
    /**
     * Encodes the data to a JSON-serializable hex-string.
     *
     * @returns The hex-string representation of the data.
     */
    toJSON(): HexString;
    /**
     * Takes a hex-string and converts it to an instance of type {@linkcode DataBlob}.
     * The method expects the string to be prefixed with a 2-byte length like the one returned by {@linkcode toJSON}.
     *
     * @param value Hex-string to be converted to a DataBlob.
     * @returns The parsed instance.
     */
    static fromJSON(value: HexString): DataBlob;
    /**
     * Takes an {@linkcode Type} and transforms it to a {@linkcode TypedJson} format.
     *
     * @returns {TypedJson} The transformed object.
     */
    toTypedJSON(): TypedJson<Serializable>;
    /**
     * Takes a {@linkcode TypedJson} object and converts it to instance of type {@linkcode DataBlob}.
     *
     * @param {TypedJson} json - The typed JSON to convert.
     * @throws {TypedJsonParseError} - If unexpected JSON string is passed.
     * @returns {DataBlob} The parsed instance.
     */
    static fromTypedJSON: ({ ["@type"]: type, value }: TypedJson<string>) => string | DataBlob;
}
