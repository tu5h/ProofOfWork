/**
 * Discriminator for {@linkcode TypedJson}. The member used to identify each type is
 * exported from each type module and can be accessed through named export `JSON_DISCRIMINATOR`.
 */
export declare enum TypedJsonDiscriminator {
    AccountAddress = "ccd_account_address",
    BlockHash = "ccd_block_hash",
    CcdAmount = "ccd_ccd_amount",
    ContractAddress = "ccd_contract_address",
    ContractName = "ccd_contract_name",
    CredentialRegistrationId = "ccd_cred_reg_id",
    DataBlob = "ccd_data_blob",
    Duration = "ccd_duration",
    Energy = "ccd_energy",
    EntrypointName = "ccd_entrypoint_name",
    InitName = "ccd_init_name",
    ModuleReference = "ccd_module_reference",
    Parameter = "ccd_parameter",
    ReceiveName = "ccd_receive_name",
    ReturnValue = "ccd_return_value",
    SequenceNumber = "ccd_sequence_number",
    Timestamp = "ccd_timestamp",
    TransactionExpiry = "ccd_transaction_expiry",
    TransactionHash = "ccd_transaction_hash"
}
/**
 * Type describing the JSON representation of strong types used in the SDK.
 *
 * @template V - The serializable JSON value
 */
export type TypedJson<V> = {
    /** The type discriminator */
    ['@type']: TypedJsonDiscriminator;
    /** The serializable type value */
    value: V;
};
/**
 * Type predeicate for {@linkcode TypedJson}.
 *
 * @param value value to test
 * @returns boolean indicating whether `value` is {@linkcode TypedJson}
 */
export declare function isTypedJsonCandidate(value: unknown): value is TypedJson<any>;
/**
 * Describes the type of the JsonParseError.
 */
export declare enum TypedJsonParseErrorCode {
    /** Malformed JSON passed to parser function */
    MALFORMED = "MALFORMED",
    /** JSON passed to parser function had unexpected {@linkcode TypedJsonDiscriminator} type discriminator */
    WRONG_TYPE = "WRONG_TYPE",
    /** Value could not be parsed successfully */
    INVALID_VALUE = "INVALID_VALUE"
}
/**
 * Error thrown from trying to parse objects of type {@linkcode TypedJson}
 */
export declare abstract class TypedJsonParseError extends Error {
    abstract readonly code: TypedJsonParseErrorCode;
    private _name;
    /**
     * @param {string} message - The error message.
     */
    constructor(message: string);
    get name(): string;
}
export declare class TypedJsonMalformedError extends TypedJsonParseError {
    code: TypedJsonParseErrorCode;
}
export declare class TypedJsonWrongTypeError extends TypedJsonParseError {
    readonly expected: TypedJsonDiscriminator;
    readonly actual: TypedJsonDiscriminator;
    code: TypedJsonParseErrorCode;
    /**
     * @param {TypedJsonDiscriminator} expected - The discriminator expected by the typed JSON parser.
     * @param {TypedJsonDiscriminator} actual - The discriminator received by the typed JSON parser.
     */
    constructor(expected: TypedJsonDiscriminator, actual: TypedJsonDiscriminator);
}
export declare class TypedJsonInvalidValueError extends TypedJsonParseError {
    readonly inner: unknown;
    code: TypedJsonParseErrorCode;
    /**
     * @param {string} inner - The original cause of the error.
     */
    constructor(inner: unknown);
}
/**
 * Creates a function to convert {@linkcode TypedJson} to their corresponding type instance.
 *
 * @template V - The JSON value
 * @template T - The type returned
 *
 * @param {TypedJsonDiscriminator} expectedTypeDiscriminator - The discriminator expected in the JSON string parsed
 * @param {Function} toType - A function converting values of type `V` to instances of type `T`
 *
 * @throws {TypedJsonParseError} {@linkcode TypedJsonParseError} if the returned function fails to parse the passed value.
 *
 * @returns The JSON parser function
 */
export declare function makeFromTypedJson<V, T>(expectedTypeDiscriminator: TypedJsonDiscriminator, toType: (value: V) => T): ({ ["@type"]: type, value }: TypedJson<V>) => T | V;
