import { Health } from "./health.js";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
/**
 * @generated from protobuf service concordium.health.Health
 */
export class HealthClient {
    constructor(_transport) {
        this._transport = _transport;
        this.typeName = Health.typeName;
        this.methods = Health.methods;
        this.options = Health.options;
    }
    /**
     * Check the health of the node. By necessity this involves a number of
     * heuristics since in a distributed network we have to rely on the local
     * information only and we don't have authoritative data on, e.g., last
     * finalized block.
     *
     * In particular, a node that is not caught up to the head of the chain is not
     * healthy.
     *
     * If possible the client should use other queries to get a more fine-grained
     * understanding of the node health. However this endpoint should provide a
     * reasonable default and is usable in cases where an automatic check is
     * performed that does not allow for configuration, such as in load-balancers.
     *
     * @generated from protobuf rpc: Check(concordium.health.NodeHealthRequest) returns (concordium.health.NodeHealthResponse);
     */
    check(input, options) {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
}
//# sourceMappingURL=health.client.js.map