import { Queries } from "./service.js";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
/**
 * @generated from protobuf service concordium.v2.Queries
 */
export class QueriesClient {
    constructor(_transport) {
        this._transport = _transport;
        this.typeName = Queries.typeName;
        this.methods = Queries.methods;
        this.options = Queries.options;
    }
    /**
     * Return a stream of blocks that arrive from the time the query is made onward.
     * This can be used to listen for incoming blocks.
     *
     * @generated from protobuf rpc: GetBlocks(concordium.v2.Empty) returns (stream concordium.v2.ArrivedBlockInfo);
     */
    getBlocks(input, options) {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Return a stream of blocks that are finalized from the time the query is
     * made onward. This can be used to listen for newly finalized blocks. Note
     * that there is no guarantee that blocks will not be skipped if the client is
     * too slow in processing the stream, however blocks will always be sent by
     * increasing block height.
     *
     * @generated from protobuf rpc: GetFinalizedBlocks(concordium.v2.Empty) returns (stream concordium.v2.FinalizedBlockInfo);
     */
    getFinalizedBlocks(input, options) {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Retrieve the information about the given account in the given block.
     *
     * @generated from protobuf rpc: GetAccountInfo(concordium.v2.AccountInfoRequest) returns (concordium.v2.AccountInfo);
     */
    getAccountInfo(input, options) {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * Retrieve the list of accounts that exist at the end of the given block.
     *
     * @generated from protobuf rpc: GetAccountList(concordium.v2.BlockHashInput) returns (stream concordium.v2.AccountAddress);
     */
    getAccountList(input, options) {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get a list of all smart contract modules. The stream will end
     * when all modules that exist in the state at the end of the given
     * block have been returned.
     *
     * @generated from protobuf rpc: GetModuleList(concordium.v2.BlockHashInput) returns (stream concordium.v2.ModuleRef);
     */
    getModuleList(input, options) {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get a stream of ancestors for the provided block.
     * Starting with the provided block itself, moving backwards until no more
     * ancestors or the requested number of ancestors has been returned.
     *
     * @generated from protobuf rpc: GetAncestors(concordium.v2.AncestorsRequest) returns (stream concordium.v2.BlockHash);
     */
    getAncestors(input, options) {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        return stackIntercept("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get the source of a smart contract module.
     *
     * @generated from protobuf rpc: GetModuleSource(concordium.v2.ModuleSourceRequest) returns (concordium.v2.VersionedModuleSource);
     */
    getModuleSource(input, options) {
        const method = this.methods[6], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * Get a list of addresses for all smart contract instances. The stream
     * will end when all instances that exist in the state at the end of the
     * given block has been returned.
     *
     * @generated from protobuf rpc: GetInstanceList(concordium.v2.BlockHashInput) returns (stream concordium.v2.ContractAddress);
     */
    getInstanceList(input, options) {
        const method = this.methods[7], opt = this._transport.mergeOptions(options);
        return stackIntercept("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get info about a smart contract instance as it appears at the end of the
     * given block.
     *
     * @generated from protobuf rpc: GetInstanceInfo(concordium.v2.InstanceInfoRequest) returns (concordium.v2.InstanceInfo);
     */
    getInstanceInfo(input, options) {
        const method = this.methods[8], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * Get the exact state of a specific contract instance, streamed as a list of
     * key-value pairs. The list is streamed in lexicographic order of keys.
     *
     * @generated from protobuf rpc: GetInstanceState(concordium.v2.InstanceInfoRequest) returns (stream concordium.v2.InstanceStateKVPair);
     */
    getInstanceState(input, options) {
        const method = this.methods[9], opt = this._transport.mergeOptions(options);
        return stackIntercept("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get the value at a specific key of a contract state. In contrast to
     * `GetInstanceState` this is more efficient, but requires the user to know
     * the specific key to look for.
     *
     * @generated from protobuf rpc: InstanceStateLookup(concordium.v2.InstanceStateLookupRequest) returns (concordium.v2.InstanceStateValueAtKey);
     */
    instanceStateLookup(input, options) {
        const method = this.methods[10], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * Get the best guess as to what the next account sequence number should be.
     * If all account transactions are finalized then this information is reliable.
     * Otherwise this is the best guess, assuming all other transactions will be
     * committed to blocks and eventually finalized.
     *
     * @generated from protobuf rpc: GetNextAccountSequenceNumber(concordium.v2.AccountAddress) returns (concordium.v2.NextAccountSequenceNumber);
     */
    getNextAccountSequenceNumber(input, options) {
        const method = this.methods[11], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * Get information about the current state of consensus.
     *
     * @generated from protobuf rpc: GetConsensusInfo(concordium.v2.Empty) returns (concordium.v2.ConsensusInfo);
     */
    getConsensusInfo(input, options) {
        const method = this.methods[12], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * Get the status of and information about a specific block item (transaction).
     *
     * @generated from protobuf rpc: GetBlockItemStatus(concordium.v2.TransactionHash) returns (concordium.v2.BlockItemStatus);
     */
    getBlockItemStatus(input, options) {
        const method = this.methods[13], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * Get the cryptographic parameters in a given block.
     *
     * @generated from protobuf rpc: GetCryptographicParameters(concordium.v2.BlockHashInput) returns (concordium.v2.CryptographicParameters);
     */
    getCryptographicParameters(input, options) {
        const method = this.methods[14], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * Get information, such as height, timings, and transaction counts for the given block.
     *
     * @generated from protobuf rpc: GetBlockInfo(concordium.v2.BlockHashInput) returns (concordium.v2.BlockInfo);
     */
    getBlockInfo(input, options) {
        const method = this.methods[15], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * Get all the bakers at the end of the given block.
     *
     * @generated from protobuf rpc: GetBakerList(concordium.v2.BlockHashInput) returns (stream concordium.v2.BakerId);
     */
    getBakerList(input, options) {
        const method = this.methods[16], opt = this._transport.mergeOptions(options);
        return stackIntercept("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get information about a given pool at the end of a given block.
     *
     * @generated from protobuf rpc: GetPoolInfo(concordium.v2.PoolInfoRequest) returns (concordium.v2.PoolInfoResponse);
     */
    getPoolInfo(input, options) {
        const method = this.methods[17], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * Get information about the passive delegators at the end of a given block.
     *
     * @generated from protobuf rpc: GetPassiveDelegationInfo(concordium.v2.BlockHashInput) returns (concordium.v2.PassiveDelegationInfo);
     */
    getPassiveDelegationInfo(input, options) {
        const method = this.methods[18], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * Get a list of live blocks at a given height.
     *
     * @generated from protobuf rpc: GetBlocksAtHeight(concordium.v2.BlocksAtHeightRequest) returns (concordium.v2.BlocksAtHeightResponse);
     */
    getBlocksAtHeight(input, options) {
        const method = this.methods[19], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * Get information about tokenomics at the end of a given block.
     *
     * @generated from protobuf rpc: GetTokenomicsInfo(concordium.v2.BlockHashInput) returns (concordium.v2.TokenomicsInfo);
     */
    getTokenomicsInfo(input, options) {
        const method = this.methods[20], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * Run the smart contract entrypoint in a given context and in the state at
     * the end of the given block.
     *
     * @generated from protobuf rpc: InvokeInstance(concordium.v2.InvokeInstanceRequest) returns (concordium.v2.InvokeInstanceResponse);
     */
    invokeInstance(input, options) {
        const method = this.methods[21], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * Get the registered delegators of a given pool at the end of a given block.
     * In contrast to the `GetPoolDelegatorsRewardPeriod` which returns delegators
     * that are fixed for the reward period of the block, this endpoint returns the
     * list of delegators that are registered in the block. Any changes to delegators
     * are immediately visible in this list.
     * The stream will end when all the delegators has been returned.
     *
     * @generated from protobuf rpc: GetPoolDelegators(concordium.v2.GetPoolDelegatorsRequest) returns (stream concordium.v2.DelegatorInfo);
     */
    getPoolDelegators(input, options) {
        const method = this.methods[22], opt = this._transport.mergeOptions(options);
        return stackIntercept("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get the fixed delegators of a given pool for the reward period of the given block.
     * In contracts to the `GetPoolDelegators` which returns delegators registered
     * for the given block, this endpoint returns the fixed delegators contributing
     * stake in the reward period containing the given block.
     * The stream will end when all the delegators has been returned.
     *
     * @generated from protobuf rpc: GetPoolDelegatorsRewardPeriod(concordium.v2.GetPoolDelegatorsRequest) returns (stream concordium.v2.DelegatorRewardPeriodInfo);
     */
    getPoolDelegatorsRewardPeriod(input, options) {
        const method = this.methods[23], opt = this._transport.mergeOptions(options);
        return stackIntercept("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get the registered passive delegators at the end of a given block.
     * In contrast to the `GetPassiveDelegatorsRewardPeriod` which returns delegators
     * that are fixed for the reward period of the block, this endpoint returns the
     * list of delegators that are registered in the block. Any changes to delegators
     * are immediately visible in this list.
     * The stream will end when all the delegators has been returned.
     *
     * @generated from protobuf rpc: GetPassiveDelegators(concordium.v2.BlockHashInput) returns (stream concordium.v2.DelegatorInfo);
     */
    getPassiveDelegators(input, options) {
        const method = this.methods[24], opt = this._transport.mergeOptions(options);
        return stackIntercept("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get the fixed passive delegators for the reward period of the given block.
     * In contracts to the `GetPassiveDelegators` which returns delegators registered
     * for the given block, this endpoint returns the fixed delegators contributing
     * stake in the reward period containing the given block.
     * The stream will end when all the delegators has been returned.
     *
     * @generated from protobuf rpc: GetPassiveDelegatorsRewardPeriod(concordium.v2.BlockHashInput) returns (stream concordium.v2.DelegatorRewardPeriodInfo);
     */
    getPassiveDelegatorsRewardPeriod(input, options) {
        const method = this.methods[25], opt = this._transport.mergeOptions(options);
        return stackIntercept("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get the current branches of blocks starting from and including the last finalized block.
     *
     * @generated from protobuf rpc: GetBranches(concordium.v2.Empty) returns (concordium.v2.Branch);
     */
    getBranches(input, options) {
        const method = this.methods[26], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * Get information related to the baker election for a particular block.
     *
     * @generated from protobuf rpc: GetElectionInfo(concordium.v2.BlockHashInput) returns (concordium.v2.ElectionInfo);
     */
    getElectionInfo(input, options) {
        const method = this.methods[27], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * Get the identity providers registered as of the end of a given block.
     * The stream will end when all the identity providers have been returned.
     *
     * @generated from protobuf rpc: GetIdentityProviders(concordium.v2.BlockHashInput) returns (stream concordium.v2.IpInfo);
     */
    getIdentityProviders(input, options) {
        const method = this.methods[28], opt = this._transport.mergeOptions(options);
        return stackIntercept("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get the anonymity revokers registered as of the end of a given block.
     * The stream will end when all the anonymity revokers have been returned.
     *
     * @generated from protobuf rpc: GetAnonymityRevokers(concordium.v2.BlockHashInput) returns (stream concordium.v2.ArInfo);
     */
    getAnonymityRevokers(input, options) {
        const method = this.methods[29], opt = this._transport.mergeOptions(options);
        return stackIntercept("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get a list of non-finalized transaction hashes for a given account. This
     * endpoint is not expected to return a large amount of data in most cases,
     * but in bad network condtions it might. The stream will end when all the
     * non-finalized transaction hashes have been returned.
     *
     * @generated from protobuf rpc: GetAccountNonFinalizedTransactions(concordium.v2.AccountAddress) returns (stream concordium.v2.TransactionHash);
     */
    getAccountNonFinalizedTransactions(input, options) {
        const method = this.methods[30], opt = this._transport.mergeOptions(options);
        return stackIntercept("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get a list of transaction events in a given block.
     * The stream will end when all the transaction events for a given block have been returned.
     *
     * @generated from protobuf rpc: GetBlockTransactionEvents(concordium.v2.BlockHashInput) returns (stream concordium.v2.BlockItemSummary);
     */
    getBlockTransactionEvents(input, options) {
        const method = this.methods[31], opt = this._transport.mergeOptions(options);
        return stackIntercept("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get a list of special events in a given block. These are events generated
     * by the protocol, such as minting and reward payouts. They are not directly
     * generated by any transaction. The stream will end when all the special
     * events for a given block have been returned.
     *
     * @generated from protobuf rpc: GetBlockSpecialEvents(concordium.v2.BlockHashInput) returns (stream concordium.v2.BlockSpecialEvent);
     */
    getBlockSpecialEvents(input, options) {
        const method = this.methods[32], opt = this._transport.mergeOptions(options);
        return stackIntercept("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get the pending updates to chain parameters at the end of a given block.
     * The stream will end when all the pending updates for a given block have been returned.
     *
     * @generated from protobuf rpc: GetBlockPendingUpdates(concordium.v2.BlockHashInput) returns (stream concordium.v2.PendingUpdate);
     */
    getBlockPendingUpdates(input, options) {
        const method = this.methods[33], opt = this._transport.mergeOptions(options);
        return stackIntercept("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get next available sequence numbers for updating chain parameters after a given block.
     *
     * @generated from protobuf rpc: GetNextUpdateSequenceNumbers(concordium.v2.BlockHashInput) returns (concordium.v2.NextUpdateSequenceNumbers);
     */
    getNextUpdateSequenceNumbers(input, options) {
        const method = this.methods[34], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * Get the projected earliest time at which a particular baker will be required to bake a block.
     * If the current consensus version is 0, this returns the status 'Unavailable', as the endpoint
     * is only supported by consensus version 1.
     *
     * If the baker is not a baker for the current reward period, this returns a timestamp at the
     * start of the next reward period. If the baker is a baker for the current reward period, the
     * earliest win time is projected from the current round forward, assuming that each round after
     * the last finalized round will take the minimum block time. (If blocks take longer, or timeouts
     * occur, the actual time may be later, and the reported time in subsequent queries may reflect
     * this.) At the end of an epoch (or if the baker is not projected to bake before the end of the
     * epoch) the earliest win time for a (current) baker will be projected as the start of the next
     * epoch. This is because the seed for the leader election is updated at the epoch boundary, and
     * so the winners cannot be predicted beyond that. Note that in some circumstances the returned
     * timestamp can be in the past, especially at the end of an epoch.
     *
     * @generated from protobuf rpc: GetBakerEarliestWinTime(concordium.v2.BakerId) returns (concordium.v2.Timestamp);
     */
    getBakerEarliestWinTime(input, options) {
        const method = this.methods[35], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * Shut down the node.
     * Return a GRPC error if the shutdown failed.
     *
     * @generated from protobuf rpc: Shutdown(concordium.v2.Empty) returns (concordium.v2.Empty);
     */
    shutdown(input, options) {
        const method = this.methods[36], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * Suggest to a peer to connect to the submitted peer details.
     * This, if successful, adds the peer to the list of given addresses.
     * Otherwise return a GRPC error.
     * Note. The peer might not be connected to instantly, in that case
     * the node will try to establish the connection in near future. This
     * function returns a GRPC status 'Ok' in this case.
     *
     * @generated from protobuf rpc: PeerConnect(concordium.v2.IpSocketAddress) returns (concordium.v2.Empty);
     */
    peerConnect(input, options) {
        const method = this.methods[37], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * Disconnect from the peer and remove them from the given addresses list
     * if they are on it. Return if the request was processed successfully.
     * Otherwise return a GRPC error.
     *
     * @generated from protobuf rpc: PeerDisconnect(concordium.v2.IpSocketAddress) returns (concordium.v2.Empty);
     */
    peerDisconnect(input, options) {
        const method = this.methods[38], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * Get a list of banned peers.
     *
     * @generated from protobuf rpc: GetBannedPeers(concordium.v2.Empty) returns (concordium.v2.BannedPeers);
     */
    getBannedPeers(input, options) {
        const method = this.methods[39], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * Ban the given peer.
     * Returns a GRPC error if the action failed.
     *
     * @generated from protobuf rpc: BanPeer(concordium.v2.PeerToBan) returns (concordium.v2.Empty);
     */
    banPeer(input, options) {
        const method = this.methods[40], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * Unban the banned peer.
     * Returns a GRPC error if the action failed.
     *
     * @generated from protobuf rpc: UnbanPeer(concordium.v2.BannedPeer) returns (concordium.v2.Empty);
     */
    unbanPeer(input, options) {
        const method = this.methods[41], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * Start dumping packages into the specified file.
     * Only enabled if the node was built with the `network_dump` feature.
     * Returns a GRPC error if the network dump failed to start.
     *
     * @generated from protobuf rpc: DumpStart(concordium.v2.DumpRequest) returns (concordium.v2.Empty);
     */
    dumpStart(input, options) {
        const method = this.methods[42], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * Stop dumping packages.
     * Only enabled if the node was built with the `network_dump` feature.
     * Returns a GRPC error if the network dump failed to be stopped.
     *
     * @generated from protobuf rpc: DumpStop(concordium.v2.Empty) returns (concordium.v2.Empty);
     */
    dumpStop(input, options) {
        const method = this.methods[43], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * / Get a list of the peers that the node is connected to
     * / and assoicated network related information for each peer.
     *
     * @generated from protobuf rpc: GetPeersInfo(concordium.v2.Empty) returns (concordium.v2.PeersInfo);
     */
    getPeersInfo(input, options) {
        const method = this.methods[44], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * Get information about the node.
     * The `NodeInfo` includes information of
     * * Meta information such as the, version of the node, type of the node, uptime and the local time of the node.
     * * NetworkInfo which yields data such as the node id, packets sent/received,
     *   average bytes per second sent/received.
     * * ConsensusInfo. The `ConsensusInfo` returned depends on if the node supports
     *   the protocol on chain and whether the node is configured as a baker or not.
     *
     * @generated from protobuf rpc: GetNodeInfo(concordium.v2.Empty) returns (concordium.v2.NodeInfo);
     */
    getNodeInfo(input, options) {
        const method = this.methods[45], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * Send a block item. A block item is either an `AccountTransaction`, which is
     * a transaction signed and paid for by an account, a `CredentialDeployment`,
     * which creates a new account, or `UpdateInstruction`, which is an
     * instruction to change some parameters of the chain. Update instructions can
     * only be sent by the governance committee.
     *
     * Returns a hash of the block item, which can be used with
     * `GetBlockItemStatus`.
     *
     * @generated from protobuf rpc: SendBlockItem(concordium.v2.SendBlockItemRequest) returns (concordium.v2.TransactionHash);
     */
    sendBlockItem(input, options) {
        const method = this.methods[46], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * Get the hash to be signed for an account transaction. The hash returned
     * should be signed and the signatures included as an
     * AccountTransactionSignature when calling `SendBlockItem`. This is provided as
     * a convenience to support cases where the right SDK is not available for
     * interacting with the node. If an SDK is available then it is strongly
     * recommended to compute this hash off-line using it. That reduces the trust
     * in the node, removes networking failure modes, and will perform better.
     *
     * @generated from protobuf rpc: GetAccountTransactionSignHash(concordium.v2.PreAccountTransaction) returns (concordium.v2.AccountTransactionSignHash);
     */
    getAccountTransactionSignHash(input, options) {
        const method = this.methods[47], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * Get the values of chain parameters in effect in the given block.
     *
     * @generated from protobuf rpc: GetBlockChainParameters(concordium.v2.BlockHashInput) returns (concordium.v2.ChainParameters);
     */
    getBlockChainParameters(input, options) {
        const method = this.methods[48], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * Get the summary of the finalization data in a given block.
     *
     * @generated from protobuf rpc: GetBlockFinalizationSummary(concordium.v2.BlockHashInput) returns (concordium.v2.BlockFinalizationSummary);
     */
    getBlockFinalizationSummary(input, options) {
        const method = this.methods[49], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * Get the items of a block.
     *
     * @generated from protobuf rpc: GetBlockItems(concordium.v2.BlockHashInput) returns (stream concordium.v2.BlockItem);
     */
    getBlockItems(input, options) {
        const method = this.methods[50], opt = this._transport.mergeOptions(options);
        return stackIntercept("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get all bakers in the reward period of a block.
     * This endpoint is only supported for protocol version 6 and onwards.
     * If the protocol does not support the endpoint then an  'IllegalArgument' error is returned.
     *
     * @generated from protobuf rpc: GetBakersRewardPeriod(concordium.v2.BlockHashInput) returns (stream concordium.v2.BakerRewardPeriodInfo);
     */
    getBakersRewardPeriod(input, options) {
        const method = this.methods[51], opt = this._transport.mergeOptions(options);
        return stackIntercept("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * For a non-genesis block, this returns the quorum certificate, a timeout
     * certificate (if present) and epoch finalization entry (if present).
     * Note that, if the block being pointed to is not a product of ConcordiumBFT,
     * then the response will be a grpc error (invalid argument).
     * If the endpoint is not enabled by the node, then an 'unimplemented' error
     * will be returned.
     *
     * @generated from protobuf rpc: GetBlockCertificates(concordium.v2.BlockHashInput) returns (concordium.v2.BlockCertificates);
     */
    getBlockCertificates(input, options) {
        const method = this.methods[52], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * Get the list of bakers that won the lottery in a particular historical epoch (i.e. the
     * last finalized block is in a later epoch). This lists the winners for each round in the
     * epoch, starting from the round after the last block in the previous epoch, running to
     * the round before the first block in the next epoch. It also indicates if a block in each
     * round was included in the finalized chain.
     *
     * The following error cases are possible:
     *  * `NOT_FOUND` if the query specifies an unknown block.
     *  * `UNAVAILABLE` if the query is for an epoch that is not finalized in the current genesis
     * /    index, or is for a future genesis index.
     *  * `INVALID_ARGUMENT` if the query is for an epoch that is not finalized for a past genesis
     *    index.
     *  * `INVALID_ARGUMENT` if the query is for a genesis index at consensus version 0.
     *  * `INVALID_ARGUMENT` if the input `EpochRequest` is malformed.
     *  * `UNIMPLEMENTED` if the endpoint is disabled on the node.
     *
     * @generated from protobuf rpc: GetWinningBakersEpoch(concordium.v2.EpochRequest) returns (stream concordium.v2.WinningBaker);
     */
    getWinningBakersEpoch(input, options) {
        const method = this.methods[53], opt = this._transport.mergeOptions(options);
        return stackIntercept("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * Get the block hash of the first finalized block in a specified epoch.
     *
     * The following error cases are possible:
     *  * `NOT_FOUND` if the query specifies an unknown block.
     *  * `UNAVAILABLE` if the query is for an epoch that is not finalized in the current genesis
     *    index, or is for a future genesis index.
     *  * `INVALID_ARGUMENT` if the query is for an epoch with no finalized blocks for a past genesis
     *    index.
     *  * `INVALID_ARGUMENT` if the input `EpochRequest` is malformed.
     *  * `UNIMPLEMENTED` if the endpoint is disabled on the node.
     *
     * @generated from protobuf rpc: GetFirstBlockEpoch(concordium.v2.EpochRequest) returns (concordium.v2.BlockHash);
     */
    getFirstBlockEpoch(input, options) {
        const method = this.methods[54], opt = this._transport.mergeOptions(options);
        return stackIntercept("unary", this._transport, method, opt, input);
    }
    /**
     * Dry run a series of transactions and operations on a state derived from a specified block.
     * The server should send a single `DryRunResponse` for each `DryRunRequest` received, unless
     * the call fails with an error status code. If a request produces a `DryRunErrorResponse`, then
     * the server will still process subsequent requests, just as if the request causing the error
     * did not happen.
     *
     * The first request should be `load_block_at_state` to determine the block state that will be
     * used for the dry run.
     *
     * The server associates each request with an energy cost, and limits the total energy that may
     * be expended in a single invocation of `DryRun`. This limit is reported as `quota` in the
     * initial metadata returned by the server. If executing an operation exceeds the limit,
     * the server terminates the session with `RESOURCE_EXHAUSTED`.
     *
     * The server also imposes a timeout for a dry-run session to complete. The server reports
     * the timeout duration in milliseconds in the initial metadata field `timeout`. If the session
     * is not completed before the timeout elapses, the server terminates the session with
     * `DEADLINE_EXCEEDED`.
     *
     * The following error cases are possible:
     *  * `INVALID_ARGUMENT` if any `DryRunRequest` is malformed.
     *  * `RESOURCE_EXHAUSTED` if the energy quota is exceeded.
     *  * `DEADLINE_EXCEEDED` if the session does not complete before the server-imposed timeout.
     *  * `RESOURCE_EXHAUSTED` if the server is not currently accepting new `DryRun` sessions.
     *    (The server may impose a limit on the number of concurrent sessions.)
     *  * `INTERNAL` if an interal server error occurs. This should not happen, and likely indicates
     *    a bug.
     *  * `UNIMPLEMENTED` if the endpoint is disabled on the node.
     *
     * @generated from protobuf rpc: DryRun(stream concordium.v2.DryRunRequest) returns (stream concordium.v2.DryRunResponse);
     */
    dryRun(options) {
        const method = this.methods[55], opt = this._transport.mergeOptions(options);
        return stackIntercept("duplex", this._transport, method, opt);
    }
}
//# sourceMappingURL=service.client.js.map