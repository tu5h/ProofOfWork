import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import type { NodeHealthResponse } from "./health.js";
import type { NodeHealthRequest } from "./health.js";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * @generated from protobuf service concordium.health.Health
 */
export interface IHealthClient {
    /**
     * Check the health of the node. By necessity this involves a number of
     * heuristics since in a distributed network we have to rely on the local
     * information only and we don't have authoritative data on, e.g., last
     * finalized block.
     *
     * In particular, a node that is not caught up to the head of the chain is not
     * healthy.
     *
     * If possible the client should use other queries to get a more fine-grained
     * understanding of the node health. However this endpoint should provide a
     * reasonable default and is usable in cases where an automatic check is
     * performed that does not allow for configuration, such as in load-balancers.
     *
     * @generated from protobuf rpc: Check(concordium.health.NodeHealthRequest) returns (concordium.health.NodeHealthResponse);
     */
    check(input: NodeHealthRequest, options?: RpcOptions): UnaryCall<NodeHealthRequest, NodeHealthResponse>;
}
/**
 * @generated from protobuf service concordium.health.Health
 */
export declare class HealthClient implements IHealthClient, ServiceInfo {
    private readonly _transport;
    typeName: string;
    methods: import("@protobuf-ts/runtime-rpc").MethodInfo<any, any>[];
    options: {
        [extensionName: string]: import("@protobuf-ts/runtime").JsonValue;
    };
    constructor(_transport: RpcTransport);
    /**
     * Check the health of the node. By necessity this involves a number of
     * heuristics since in a distributed network we have to rely on the local
     * information only and we don't have authoritative data on, e.g., last
     * finalized block.
     *
     * In particular, a node that is not caught up to the head of the chain is not
     * healthy.
     *
     * If possible the client should use other queries to get a more fine-grained
     * understanding of the node health. However this endpoint should provide a
     * reasonable default and is usable in cases where an automatic check is
     * performed that does not allow for configuration, such as in load-balancers.
     *
     * @generated from protobuf rpc: Check(concordium.health.NodeHealthRequest) returns (concordium.health.NodeHealthResponse);
     */
    check(input: NodeHealthRequest, options?: RpcOptions): UnaryCall<NodeHealthRequest, NodeHealthResponse>;
}
