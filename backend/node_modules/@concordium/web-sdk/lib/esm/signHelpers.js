// self-referencing not allowed by eslint resolver
// eslint-disable-next-line import/no-extraneous-dependencies
import * as ed from '@concordium/web-sdk/shims/ed25519';
import { Buffer } from 'buffer/index.js';
import { sha256 } from './hash.js';
import { getAccountTransactionSignDigest } from './serialization.js';
import * as AccountAddress from './types/AccountAddress.js';
import { mapRecord } from './util.js';
/**
 * Parses a wallet export file into a WalletExportFormat. The wallet export
 * file is exported from a concordium wallet.
 */
export function parseWallet(walletString) {
    const wallet = JSON.parse(walletString);
    if (typeof wallet.type !== 'string') {
        throw Error('Expected field "type" to be of type "string" but was of type "' + typeof wallet.type + '"');
    }
    if (typeof wallet.v !== 'number') {
        throw Error('Expected field "v" to be of type "number" but was of type "' + typeof wallet.v + '"');
    }
    if (typeof wallet.environment !== 'string') {
        throw Error('Expected field "environment" to be of type "string" but was of type "' + typeof wallet.environment + '"');
    }
    if (typeof wallet.value.address !== 'string') {
        throw Error('Expected field "value.address" to be of type "string" but was of type "' +
            typeof wallet.value.address +
            '"');
    }
    if (wallet.value.accountKeys === undefined) {
        throw Error('Expected field "value.accountKeys" to be defined, but was not');
    }
    if (wallet.value.credentials === undefined) {
        throw Error('Expected field "value.credentials" to be defined, but was not');
    }
    return wallet;
}
/**
 * Gets Ed25519 signature for `digest`.
 *
 * @param {ArrayBuffer} digest - the message to sign.
 * @param {HexString} privateKey - the ed25519 private key in HEX format.
 *
 * @returns {Buffer} the signature.
 */
export const getSignature = async (digest, privateKey) => Buffer.from(await ed.signAsync(new Uint8Array(digest), privateKey));
/**
 * Creates an `AccountSigner` for an account which uses the first credential's first keypair.
 * Note that if the account has a threshold > 1 or the first credentials has a threshold > 1, the transaction signed using this will fail.
 *
 * @param {HexString} privateKey - the ed25519 private key in HEX format. (First credential's first keypair's private key)
 *
 * @returns {AccountSigner} an `AccountSigner` which creates a signature using the first credentials first keypair
 */
export function buildBasicAccountSigner(privateKey) {
    return {
        getSignatureCount() {
            return 1n;
        },
        async sign(digest) {
            const sig = await getSignature(digest, privateKey);
            return {
                0: {
                    0: sig.toString('hex'),
                },
            };
        },
    };
}
const isWalletExport = (value) => value.value?.accountKeys !== undefined;
const isSimpleAccountKeys = (value) => value.value?.accountKeys === undefined && value.accountKeys === undefined;
const getKeys = (value) => {
    if (isSimpleAccountKeys(value)) {
        return value;
    }
    const { keys } = isWalletExport(value) ? value.value.accountKeys : value.accountKeys;
    return mapRecord(keys, (credKeys) => mapRecord(credKeys.keys, (keyPair) => keyPair.signKey));
};
const getCredentialSignature = async (digest, keys) => {
    const sig = {};
    for (const key in keys) {
        const signature = await getSignature(digest, keys[key]);
        sig[key] = signature.toString('hex');
    }
    return sig;
};
export function buildAccountSigner(value) {
    if (typeof value === 'string') {
        return buildBasicAccountSigner(value);
    }
    const keys = getKeys(value);
    const numKeys = Object.values(keys).reduce((acc, credKeys) => acc + BigInt(Object.keys(credKeys).length), 0n);
    return {
        getSignatureCount() {
            return numKeys;
        },
        async sign(digest) {
            const sig = {};
            for (const key in keys) {
                sig[key] = await getCredentialSignature(digest, keys[key]);
            }
            return sig;
        },
    };
}
/**
 * Helper function to sign an AccountTransaction.
 * @param transaction the account transaction to sign
 * @param signer An object that handles the keys of the account, and performs the actual signing.
 */
export function signTransaction(transaction, signer) {
    const digest = getAccountTransactionSignDigest(transaction, signer.getSignatureCount());
    return signer.sign(digest);
}
/**
 * @param account the address of the account that will sign this message.
 * @param message the message to sign, assumed to be utf8 encoded string or a Uint8Array/buffer.
 */
function getMessageDigest(account, message) {
    const prepend = Buffer.alloc(8, 0);
    const rawMessage = typeof message === 'string' ? Buffer.from(message, 'utf8') : message;
    return sha256([AccountAddress.toBuffer(account), prepend, rawMessage]);
}
/**
 * Helper function to sign a message.
 * Note that this function prepends the account address (32 bytes) and 8 zero-bytes to ensure that the message is not a transaction.
 * Note that the current prepend is temporary and will later be replaced.
 * @param message the message to sign, assumed to be utf8 encoded string or a Uint8Array/buffer.
 * @param signer An object that handles the keys of the account, and performs the actual signing.
 */
export function signMessage(account, message, signer) {
    return signer.sign(getMessageDigest(account, message));
}
/**
 * Helper function to verify a signed message.
 * @param message the message to sign, assumed to be utf8 encoded string or a Uint8Array/buffer.
 * @param signature the signature of a message, from a specific account.
 * @param accountInfo the address and credentials of the account
 */
export async function verifyMessageSignature(message, signature, accountInfo) {
    if (Object.keys(signature).length < accountInfo.accountThreshold) {
        // Not enough credentials have signed;
        return false;
    }
    const digest = getMessageDigest(accountInfo.accountAddress, message);
    for (const credentialIndex of Object.keys(signature)) {
        const credential = accountInfo.accountCredentials[Number(credentialIndex)];
        if (!credential) {
            throw new Error('Signature contains signature for non-existing credential');
        }
        const credentialSignature = signature[Number(credentialIndex)];
        const credentialKeys = credential.value.contents.credentialPublicKeys;
        if (Object.keys(credentialSignature).length < credentialKeys.threshold) {
            // Not enough signatures for the current credential;
            return false;
        }
        for (const keyIndex of Object.keys(credentialSignature)) {
            if (!credentialKeys.keys[Number(keyIndex)]) {
                throw new Error('Signature contains signature for non-existing keyIndex');
            }
            if (!(await ed.verifyAsync(credentialSignature[Number(keyIndex)], digest, credentialKeys.keys[Number(keyIndex)].verifyKey))) {
                // Incorrect signature;
                return false;
            }
        }
    }
    return true;
}
//# sourceMappingURL=signHelpers.js.map