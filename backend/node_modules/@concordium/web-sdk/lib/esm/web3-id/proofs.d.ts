import { StatementBuilder } from '../commonProofTypes.js';
import { AttributeList, HexString, Network } from '../types.js';
import type * as ContractAddress from '../types/ContractAddress.js';
import { ConcordiumHdWallet } from '../wasm/HdWallet.js';
import { AccountCommitmentInput, AtomicStatementV2, AttributeType, CredentialSchemaSubject, CredentialStatement, CredentialStatements, CredentialSubject, StatementAttributeType, Web3IssuerCommitmentInput } from './types.js';
export declare const MAX_STRING_BYTE_LENGTH = 31;
export declare const MAX_U64 = 18446744073709551615n;
export declare const MIN_DATE_ISO = "-262144-01-01T00:00:00Z";
export declare const MAX_DATE_ISO = "+262143-12-31T23:59:59.999999999Z";
export declare const MIN_DATE_TIMESTAMP: number;
export declare const MAX_DATE_TIMESTAMP: number;
/**
 * Check that the given atomic statements are well formed and do not break any rules.
 * If they do not verify, this throw an error.
 */
export declare function verifyAtomicStatements(statements: AtomicStatementV2[], schema?: CredentialSchemaSubject): boolean;
export declare class AtomicStatementBuilder implements InternalBuilder {
    statements: AtomicStatementV2[];
    schema: CredentialSchemaSubject | undefined;
    constructor(schema?: CredentialSchemaSubject);
    /**
     * Outputs the built statement.
     */
    getStatement(): AtomicStatementV2[];
    /**
     * This checks whether the given statement may be added to the statement being built.
     * If the statement breaks any rules, this will throw an error.
     */
    private check;
    /**
     * Add to the statement, that the given attribute should be in the given range, i.e. that lower <= attribute < upper.
     * @param attribute the attribute that should be checked
     * @param lower: the lower end of the range, inclusive.
     * @param upper: the upper end of the range, exclusive.
     * @returns the updated builder
     */
    addRange(attribute: string, lower: StatementAttributeType, upper: StatementAttributeType): this;
    /**
     * Add to the statement, that the given attribute should be one of the values in the given set.
     * @param attribute the attribute that should be checked
     * @param set: the set of values that the attribute must be included in.
     * @returns the updated builder
     */
    addMembership(attribute: string, set: StatementAttributeType[]): this;
    /**
     * Add to the statement, that the given attribute should _not_ be one of the values in the given set.
     * @param attribute the attribute that should be checked
     * @param set: the set of values that the attribute must be included in.
     * @returns the updated builder
     */
    addNonMembership(attribute: string, set: StatementAttributeType[]): this;
    /**
     * Add to the statement, that the given attribute should be revealed.
     * The proof will contain the value.
     * @param attribute the attribute that should be revealed
     * @returns the updated builder
     */
    revealAttribute(attribute: string): this;
}
export declare class AccountStatementBuild extends AtomicStatementBuilder {
    /**
     * Add to the statement that the age is at minimum the given value.
     * This adds a range statement that the date of birth is between 1st of january 1800 and <age> years ago.
     * @param age: the minimum age allowed.
     * @returns the updated builder
     */
    addMinimumAge(age: number): AtomicStatementBuilder;
    /**
     * Add to the statement that the age is at maximum the given value.
     * This adds a range statement that the date of birth is between <age + 1> years ago and 1st of january 9999.
     * @param age: the maximum age allowed.
     * @returns the updated builder
     */
    addMaximumAge(age: number): AtomicStatementBuilder;
    /**
     * Add to the statement that the age is between two given ages.
     * This adds a range statement that the date of birth is between <maxAge> years ago and <minAge> years ago.
     * @param minAge: the maximum age allowed.
     * @param maxAge: the maximum age allowed.
     * @returns the updated builder
     */
    addAgeInRange(minAge: number, maxAge: number): AtomicStatementBuilder;
    /**
     * Add to the statement that the user's document expiry is atleast the given date.
     * This adds a range statement that the idDocExpiresAt is between the given date and 1st of january 9999 .
     * @param earliestDate: the earliest the document is allow to be expired at, should be a string in YYYYMMDD format.
     * @returns the updated builder
     */
    documentExpiryNoEarlierThan(earliestDate: string): AtomicStatementBuilder;
    /**
     * Add to the statement that the country of residence is one of the EU countries
     * @returns the updated builder
     */
    addEUResidency(): AtomicStatementBuilder;
    /**
     * Add to the statement that the nationality is one of the EU countries
     * @returns the updated builder
     */
    addEUNationality(): AtomicStatementBuilder;
}
type InternalBuilder = StatementBuilder<StatementAttributeType, string>;
export declare class Web3StatementBuilder {
    private statements;
    private add;
    addForVerifiableCredentials(validContractAddresses: ContractAddress.Type[], builderCallback: (builder: InternalBuilder) => void, schema?: CredentialSchemaSubject): this;
    addForIdentityCredentials(validIdentityProviders: number[], builderCallback: (builder: InternalBuilder) => void): this;
    getStatements(): CredentialStatements;
}
/**
 * Create a DID string for a web3id credential. Used to build a request for a verifiable credential.
 */
export declare function createWeb3IdDID(network: Network, publicKey: string, index: bigint, subindex: bigint): string;
/**
 * Create a DID string for a web3id credential. Used to build a request for a verifiable credential.
 */
export declare function createAccountDID(network: Network, credId: string): string;
/**
 * Create the commitment input required to create a proof for the given statements, using an account credential.
 */
export declare function createAccountCommitmentInput(statements: AtomicStatementV2[], identityProvider: number, attributes: AttributeList, randomness: Record<number, string>): AccountCommitmentInput;
/**
 * Create the commitment input required to create a proof for the given statements, using an account credential.
 * Uses a ConcordiumHdWallet to get randomness needed.
 */
export declare function createAccountCommitmentInputWithHdWallet(statements: AtomicStatementV2[], identityProvider: number, attributes: AttributeList, wallet: ConcordiumHdWallet, identityIndex: number, credIndex: number): AccountCommitmentInput;
/**
 * Create the commitment input required to create a proof for the given statements, using an web3Id credential.
 */
export declare function createWeb3CommitmentInput(verifiableCredentialPrivateKey: HexString, credentialSubject: CredentialSubject, randomness: Record<string, string>, signature: string): Web3IssuerCommitmentInput;
/**
 * Create the commitment input required to create a proof for the given statements, using an web3Id credential.
 * Uses a ConcordiumHdWallet to supply the public key and the signing key of the credential.
 */
export declare function createWeb3CommitmentInputWithHdWallet(wallet: ConcordiumHdWallet, issuer: ContractAddress.Type, credentialIndex: number, credentialSubject: CredentialSubject, randomness: Record<string, string>, signature: string): Web3IssuerCommitmentInput;
/**
 * Given an atomic statement and a prover's attributes, determine whether the statement is fulfilled.
 */
export declare function canProveAtomicStatement(statement: AtomicStatementV2, attributes: Record<string, AttributeType>): boolean;
/**
 * Given a credential statement and a prover's attributes, determine whether the statements are fulfilled.
 */
export declare function canProveCredentialStatement(credentialStatement: CredentialStatement, attributes: Record<string, AttributeType>): boolean;
export {};
