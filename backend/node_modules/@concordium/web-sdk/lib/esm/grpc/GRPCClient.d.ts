/**
 * This is the GRPC-Client used by both the Web-SDK and the NodeJS-SDK. Check
 * out the {@link ConcordiumGRPCClient}
 *
 * @module Common GRPC-Client
 */
import { GrpcWebOptions } from '@protobuf-ts/grpcweb-transport';
import type { RpcTransport } from '@protobuf-ts/runtime-rpc';
import { HealthClient } from '../grpc-api/v2/concordium/health.client.js';
import { QueriesClient } from '../grpc-api/v2/concordium/service.client.js';
import * as v2 from '../grpc-api/v2/concordium/types.js';
import * as v1 from '../types.js';
import { HexString } from '../types.js';
import * as AccountAddress from '../types/AccountAddress.js';
import * as BlockHash from '../types/BlockHash.js';
import * as ContractAddress from '../types/ContractAddress.js';
import * as Energy from '../types/Energy.js';
import * as ModuleReference from '../types/ModuleReference.js';
import * as Timestamp from '../types/Timestamp.js';
import * as TransactionExpiry from '../types/TransactionExpiry.js';
import * as TransactionHash from '../types/TransactionHash.js';
import type { BlockItemStatus, BlockItemSummary } from '../types/blockItemSummary.js';
/**
 * @hidden
 */
export type FindInstanceCreationReponse = {
    hash: BlockHash.Type;
    height: bigint;
    instanceInfo: v1.InstanceInfo;
};
/**
 * A concordium-node specific gRPC client wrapper. Only use this if you intend to supply a custom
 * transport layer. Otherwise more user-friendly options {@linkcode ConcordiumGRPCWebClient} and
 * `ConcordiumGRPCNodeClient` exist for web/nodejs use respectively.
 */
export declare class ConcordiumGRPCClient {
    client: QueriesClient;
    healthClient: HealthClient;
    /**
     * Initialize a gRPC client for a specific concordium node.
     * @param transport RpcTransport to send communication over
     */
    constructor(transport: RpcTransport);
    /**
     * Retrieves the next account nonce for the given account. The account nonce is
     * used in all account transactions as part of their header.
     *
     * {@codeblock ~~:nodejs/client/getNextAccountSequenceNumber.ts#documentation-snippet}
     *
     * @param accountAddress base58 account address to get the next account nonce for.
     *
     * @returns the next account nonce, and a boolean indicating if the nonce is reliable.
     */
    getNextAccountNonce(accountAddress: AccountAddress.Type): Promise<v1.NextAccountNonce>;
    /**
     * Retrieves the consensus status information from the node. Note that the optional
     * fields will only be unavailable for a newly started node that has not processed
     * enough data yet.
     *
     * {@codeblock ~~:nodejs/client/getCryptographicParameters.ts#documentation-snippet}
     *
     * @param blockHash optional block hash to get the cryptographic parameters at, otherwise retrieves from last finalized block.
     * @returns the global cryptographic parameters at the given block, or undefined it the block does not exist.
     */
    getCryptographicParameters(blockHash?: BlockHash.Type): Promise<v1.CryptographicParameters>;
    /**
     * Retrieves the account info for the given account. If the provided block
     * hash is in a block prior to the finalization of the account, then the account
     * information will not be available.
     * A credential registration id can also be provided, instead of an address. In this case
     * the node will return the account info of the account, which the corresponding credential
     * is (or was) deployed to. An account index can also be provided.
     *
     * {@codeblock ~~:nodejs/client/getAccountInfo.ts#documentation-snippet}
     *
     * @param accountIdentifier base58 account address, or a credential registration id or account index to get the account info for
     * @param blockHash optional block hash to get the account info at, otherwise retrieves from last finalized block
     *
     * @returns the account info for the provided account address.
     * @throws An error of type `RpcError` if not found in the block.
     */
    getAccountInfo(accountIdentifier: v1.AccountIdentifierInput, blockHash?: BlockHash.Type): Promise<v1.AccountInfo>;
    /**
     * Retrieves a status for the given transaction/block item.
     *
     * {@codeblock ~~:nodejs/client/getBlockItemStatus.ts#documentation-snippet}
     *
     * @param transactionHash the transaction/block item to get a status for.
     *
     * @returns the status for the given transaction/block item, or undefined if it does not exist.
     */
    getBlockItemStatus(transactionHash: TransactionHash.Type): Promise<BlockItemStatus>;
    /**
     * Retrieves the consensus status information from the node. Note that the optional
     * fields will only be unavailable for a newly started node that has not processed
     * enough data yet.
     *
     * {@codeblock ~~:nodejs/client/getConsensusStatus.ts#documentation-snippet}
     */
    getConsensusStatus(): Promise<v1.ConsensusStatus>;
    /**
     * Retrieves the source of the given module at the provided block.
     *
     * {@codeblock ~~:nodejs/client/getModuleSource.ts#documentation-snippet}
     *
     * @param moduleRef the module's reference, represented by the ModuleReference class.
     * @param blockHash optional block hash to get the module source at, otherwise retrieves from last finalized block
     *
     * @returns the source of the module as raw bytes.
     * @throws An error of type `RpcError` if not found in the block.
     */
    getModuleSource(moduleRef: ModuleReference.Type, blockHash?: BlockHash.Type): Promise<v1.VersionedModuleSource>;
    /**
     * Retrieves the embedded schema of the given module at the provided block.
     *
     * {@codeblock ~~:nodejs/client/getEmbeddedSchema.ts#documentation-snippet}
     *
     * @param moduleRef the module's reference, represented by the ModuleReference class.
     * @param blockHash optional block hash to get the module embedded schema at, otherwise retrieves from last finalized block
     *
     * @returns the module schema as a buffer.
     * @throws An error of type `RpcError` if not found in the block.
     * @throws If the module or schema cannot be parsed
     */
    getEmbeddedSchema(moduleRef: ModuleReference.Type, blockHash?: BlockHash.Type): Promise<Uint8Array>;
    /**
     * Retrieve information about a given smart contract instance.
     *
     * {@codeblock ~~:nodejs/client/getInstanceInfo.ts#documentation-snippet}
     *
     * @param contractAddress the address of the smart contract.
     * @param blockHash optional block hash to get the smart contact instances at, otherwise retrieves from last finalized block
     *
     * @returns An object with information about the contract instance.
     * @throws An error of type `RpcError` if not found in the block.
     */
    getInstanceInfo(contractAddress: ContractAddress.Type, blockHash?: BlockHash.Type): Promise<v1.InstanceInfo>;
    /**
     * Invokes a smart contract.
     *
     * {@codeblock ~~:nodejs/client/invokeContract.ts#documentation-snippet}
     *
     * @param context.contract The address of the smart contract that shall be evoked.
     * @param context.amount The amount of microCCD to invoke the contract with.
     * @param context.method The entrypoint (receive function) that shall be invoked.
     * @param context.parameter The serialized parameters that the contract will be invoked with.
     * @param context.energy The maximum amount of energy to allow for execution.
     * @param context.invoker The address of the invoker, if undefined uses the zero account address.
     * @param blockHash the block hash at which the contract should be invoked at. The contract is invoked in the state at the end of this block.
     *
     * @returns If the node was able to invoke, then a object describing the outcome is returned.
     * The outcome is determined by the `tag` field, which is either `success` or `failure`.
     * The `usedEnergy` field will always be present, and is the amount of NRG was used during the execution.
     * If the tag is `success`, then an `events` field is present, and it contains the events that would have been generated.
     * If invoking a V1 contract and it produces a return value, it will be present in the `returnValue` field.
     * If the tag is `failure`, then a `reason` field is present, and it contains the reason the update would have been rejected.
     * If either the block does not exist, or then node fails to parse of any of the inputs, then undefined is returned.
     */
    invokeContract(context: v1.ContractContext, blockHash?: BlockHash.Type): Promise<v1.InvokeContractResult>;
    /**
     * Serializes and sends an account transaction to the node to be
     * put in a block on the chain.
     *
     * Note that a transaction can still fail even if it was accepted by the node.
     * To keep track of the transaction use getTransactionStatus.
     *
     * {@codeblock ~~:nodejs/common/simpleTransfer.ts#documentation-snippet}
     *
     * @param transaction the transaction to send to the node
     * @param signature the signatures on the signing digest of the transaction
     * @returns The transaction hash as a hex-encoded string
     */
    sendAccountTransaction(transaction: v1.AccountTransaction, signature: v1.AccountTransactionSignature): Promise<TransactionHash.Type>;
    /**
     * Sends an account transaction, with an already serialized payload, to the node to be
     * put in a block on the chain.
     *
     * Note that a transaction can still fail even if it was accepted by the node.
     * To keep track of the transaction use getTransactionStatus.
     *
     * In general, { @link ConcordiumGRPCClient.sendAccountTransaction } is the recommended
     * method to send account transactions, as this does not require the caller to serialize the payload themselves.
     *
     * @param header the transactionheader to send to the node
     * @param energyAmount the amount of energy allotted for the transaction
     * @param payload the payload serialized to a buffer
     * @param signature the signatures on the signing digest of the transaction
     * @returns The transaction hash as a byte array
     */
    sendRawAccountTransaction(header: v1.AccountTransactionHeader, energyAmount: Energy.Type, payload: Uint8Array, signature: v1.AccountTransactionSignature): Promise<TransactionHash.Type>;
    /**
     * Sends a credential deployment transaction, for creating a new account,
     * to the node to be put in a block on the chain.
     *
     * Note that a transaction can still fail even if it was accepted by the node.
     * To keep track of the transaction use getTransactionStatus.
     *
     * See [this](git:docs/account-creation.md) document for how this function can be used.
     *
     * @param rawPayload the serialized payload, consisting of the {@link v1.CredentialDeploymentTransaction}
     * along with corresponding signatures. This can be serialized by utilizing the `serializeCredentialDeploymentPayload` function.
     * @param expiry the expiry of the transaction
     * @returns The transaction hash
     */
    sendCredentialDeploymentTransaction(rawPayload: Uint8Array, expiry: TransactionExpiry.Type): Promise<TransactionHash.Type>;
    /**
     * Sends an update instruction transaction for updating a chain parameter
     * to the node to be put in a block on the chain.
     *
     * @param updateInstructionTransaction the update instruction transaction to send to the node
     * @param signatures map of the signatures on the hash of the serialized unsigned update instruction, with the key index as map key
     * @returns The transaction hash
     */
    sendUpdateInstruction(updateInstructionTransaction: v1.UpdateInstruction, signatures: Record<number, HexString>): Promise<TransactionHash.Type>;
    /**
     * Retrieves the status of the block chain parameters at the given blockHash.
     *
     * {@codeblock ~~:nodejs/client/getBlockChainParameters.ts#documentation-snippet}
     *
     * @param blockHash the block hash of the block to get the information from.
     * @returns Info on all of the block chain parameters.
     */
    getBlockChainParameters(blockHash?: BlockHash.Type): Promise<v1.ChainParameters>;
    /**
     * Retrieves information on the baker pool of the given bakerId.
     *
     * {@codeblock ~~:nodejs/client/getPoolInfo.ts#documentation-snippet}
     *
     * @param blockHash the block hash of the block to get the information from.
     * @param bakerId the ID of the baker to get the status for.
     * @returns The status of the corresponding baker pool.
     */
    getPoolInfo(bakerId: v1.BakerId, blockHash?: BlockHash.Type): Promise<v1.BakerPoolStatus>;
    /**
     * Retrieves information on the passive delegators.
     *
     * {@codeblock ~~:nodejs/client/getPassiveDelegationInfo.ts#documentation-snippet}
     *
     * @param blockHash the block hash of the block to get the information from.
     * @returns The status of the passive delegators.
     */
    getPassiveDelegationInfo(blockHash?: BlockHash.Type): Promise<v1.PassiveDelegationStatus>;
    /**
     * Retrieves the reward status at the given blockHash
     *
     * {@codeblock ~~:nodejs/client/getTokenomicsInfo.ts#documentation-snippet}
     *
     * @param blockHash optional block hash to get the reward status at, otherwise retrieves from last finalized block
     * @returns the reward status at the given block, or undefined it the block does not exist.
     */
    getTokenomicsInfo(blockHash?: BlockHash.Type): Promise<v1.TokenomicsInfo>;
    /**
     * Gets a stream of finalized blocks.
     *
     * {@codeblock ~~:nodejs/client/getFinalizedBlocks.ts#documentation-snippet}
     *
     * @param abortSignal an AbortSignal to close the stream. Note that the
     * stream does not close itself as it is infinite, so usually you'd want
     * to provide this parameter.
     * @returns An AsyncIterator stream of finalized blocks.
     */
    getFinalizedBlocks(abortSignal?: AbortSignal): AsyncIterable<v1.FinalizedBlockInfo>;
    /**
     * Gets a stream of blocks. To get a stream of only finalized blocks
     * use `getFinalizedBlocks()` instead.
     *
     * {@codeblock ~~:nodejs/client/getBlocks.ts#documentation-snippet}
     *
     * @param abortSignal an AbortSignal to close the stream. Note that the
     * stream does not close itself as it is infinite, so usually you'd want
     * to provide this parameter.
     * @returns An AsyncIterator stream of blocks.
     */
    getBlocks(abortSignal?: AbortSignal): AsyncIterable<v1.ArrivedBlockInfo>;
    /**
     * Waits until given transaction is finalized.
     *
     * {@codeblock ~~:nodejs/common/simpleTransfer.ts#documentation-snippet}
     *
     * @param transactionHash a transaction hash as a bytearray.
     * @param timeoutTime the number of milliseconds until the function throws error.
     * @returns BlockItemSummary of the transaction.
     */
    waitForTransactionFinalization(transactionHash: TransactionHash.Type, timeoutTime?: number): Promise<v1.BlockItemSummaryInBlock>;
    /**
     * Retrieve a stream of accounts that exist at the end of the given block.
     *
     * {@codeblock ~~:nodejs/client/getAccountList.ts#documentation-snippet}
     *
     * @param blockHash an optional block hash to get the accounts at, otherwise retrieves from last finalized block.
     * @param abortSignal an optional AbortSignal to close the stream.
     * @returns an async iterable of account addresses.
     */
    getAccountList(blockHash?: BlockHash.Type, abortSignal?: AbortSignal): AsyncIterable<AccountAddress.Type>;
    /**
     * Get a stream of all smart contract modules' references. The stream will end
     * when all modules that exist in the state at the end of the given
     * block have been returned.
     *
     * {@codeblock ~~:nodejs/client/getModuleList.ts#documentation-snippet}
     *
     * @param blockHash an optional block hash to get the contract modules at, otherwise retrieves from last finalized block.
     * @param abortSignal an optional AbortSignal to close the stream.
     * @returns an async iterable of contract module references.
     */
    getModuleList(blockHash?: BlockHash.Type, abortSignal?: AbortSignal): AsyncIterable<ModuleReference.Type>;
    /**
     * Get a stream of ancestors for the provided block.
     * Starting with the provided block itself, moving backwards until no more
     * ancestors or the requested number of ancestors has been returned.
     *
     * {@codeblock ~~:nodejs/client/getAncestors.ts#documentation-snippet}
     *
     * @param maxAmountOfAncestors the maximum amount of ancestors as a bigint.
     * @param blockHash a optional block hash to get the ancestors at, otherwise retrieves from last finalized block.
     * @param abortSignal an optional AbortSignal to close the stream.
     * @returns an async iterable of ancestors' block hashes.
     */
    getAncestors(maxAmountOfAncestors: bigint, blockHash?: BlockHash.Type, abortSignal?: AbortSignal): AsyncIterable<BlockHash.Type>;
    /**
     * Get the exact state of a specific contract instance, streamed as a list of
     * key-value pairs. The list is streamed in lexicographic order of keys.
     *
     * {@codeblock ~~:nodejs/client/getInstanceState.ts#documentation-snippet}
     *
     * @param contractAddress the contract to get the state of.
     * @param blockHash a optional block hash to get the instance states at, otherwise retrieves from last finalized block.
     * @param abortSignal an optional AbortSignal to close the stream.
     * @returns an async iterable of instance states as key-value pairs of hex strings.
     */
    getInstanceState(contractAddress: ContractAddress.Type, blockHash?: BlockHash.Type, abortSignal?: AbortSignal): AsyncIterable<v1.InstanceStateKVPair>;
    /**
     * Get the value at a specific key of a contract state. In contrast to
     * `GetInstanceState` this is more efficient, but requires the user to know
     * the specific key to look for.
     *
     * {@codeblock ~~:nodejs/client/instanceStateLookup.ts#documentation-snippet}
     *
     * @param contractAddress the contract to get the state of.
     * @param key the key of the desired contract state.
     * @param blockHash a optional block hash to get the instance states at, otherwise retrieves from last finalized block.
     * @returns the state of the contract at the given key as a hex string.
     */
    instanceStateLookup(contractAddress: ContractAddress.Type, key: HexString, blockHash?: BlockHash.Type): Promise<HexString>;
    /**
     * Get the identity providers registered as of the end of a given block.
     * The stream will end when all the identity providers have been returned,
     * or an abort signal is called.
     *
     * {@codeblock ~~:nodejs/client/getIdentityProviders.ts#documentation-snippet}
     *
     * @param blockHash an optional block hash to get the providers at, otherwise retrieves from last finalized block.
     * @param abortSignal an optional AbortSignal to close the stream.
     * @returns an async iterable of identity provider info objects.
     */
    getIdentityProviders(blockHash?: BlockHash.Type, abortSignal?: AbortSignal): AsyncIterable<v1.IpInfo>;
    /**
     * Get the anonymity revokers registered as of the end of a given block.
     * The stream will end when all the anonymity revokers have been returned,
     * or an abort signal is called.
     *
     * {@codeblock ~~:nodejs/client/getAnonymityRevokers.ts#documentation-snippet}
     *
     * @param blockHash an optional block hash to get the anonymity revokers at, otherwise retrieves from last finalized block.
     * @param abortSignal an optional AbortSignal to close the stream.
     * @returns an async iterable of identity provider info objects.
     */
    getAnonymityRevokers(blockHash?: BlockHash.Type, abortSignal?: AbortSignal): AsyncIterable<v1.ArInfo>;
    /**
     * Get a list of live blocks at a given height.
     *
     * {@codeblock ~~:nodejs/client/getBlocksAtHeightAbsolute.ts#documentation-snippet}
     *
     * @param blockHeightRequest Either an absolute block height request or a relative block height request
     * @returns A list of block hashes as hex strings
     */
    getBlocksAtHeight(blockHeightRequest: v1.BlocksAtHeightRequest): Promise<BlockHash.Type[]>;
    /**
     * Get information, such as height, timings, and transaction counts for the given block.
     *
     * {@codeblock ~~:nodejs/client/getBlockInfo.ts#documentation-snippet}
     *
     * @param blockHash an optional block hash to get the info from, otherwise retrieves from last finalized block.
     * @returns information on a block.
     */
    getBlockInfo(blockHash?: BlockHash.Type): Promise<v1.BlockInfo>;
    /**
     * Get all the bakers at the end of the given block.
     *
     * {@codeblock ~~:nodejs/client/getBakerList.ts#documentation-snippet}
     *
     * @param blockHash an optional block hash to get the baker list at, otherwise retrieves from last finalized block.
     * @param abortSignal an optional AbortSignal to close the stream.
     * @returns an async iterable of BakerIds.
     */
    getBakerList(blockHash?: BlockHash.Type, abortSignal?: AbortSignal): AsyncIterable<v1.BakerId>;
    /**
     * Get the registered delegators of a given pool at the end of a given block.
     * In contrast to the `GetPoolDelegatorsRewardPeriod` which returns delegators
     * that are fixed for the reward period of the block, this endpoint returns the
     * list of delegators that are registered in the block. Any changes to delegators
     * are immediately visible in this list.
     * The stream will end when all the delegators has been returned.
     *
     * {@codeblock ~~:nodejs/client/getPoolDelegators.ts#documentation-snippet}
     *
     * @param baker The BakerId of the pool owner
     * @param blockHash an optional block hash to get the delegators at, otherwise retrieves from last finalized block.
     * @param abortSignal an optional AbortSignal to close the stream.
     * @returns a stream of DelegatorInfo
     */
    getPoolDelegators(baker: v1.BakerId, blockHash?: BlockHash.Type, abortSignal?: AbortSignal): AsyncIterable<v1.DelegatorInfo>;
    /**
     * Get the fixed delegators of a given pool for the reward period of the given block.
     * In contracts to the `GetPoolDelegators` which returns delegators registered
     * for the given block, this endpoint returns the fixed delegators contributing
     * stake in the reward period containing the given block.
     * The stream will end when all the delegators has been returned.
     *
     * {@codeblock ~~:nodejs/client/getPoolDelegatorsRewardPeriod.ts#documentation-snippet}
     *
     * @param baker The BakerId of the pool owner
     * @param blockHash an optional block hash to get the delegators at, otherwise retrieves from last finalized block.
     * @param abortSignal an optional AbortSignal to close the stream.
     * @returns a stream of DelegatorRewardPeriodInfo
     */
    getPoolDelegatorsRewardPeriod(baker: v1.BakerId, blockHash?: BlockHash.Type, abortSignal?: AbortSignal): AsyncIterable<v1.DelegatorRewardPeriodInfo>;
    /**
     * Get the registered passive delegators at the end of a given block.
     * In contrast to the `GetPassiveDelegatorsRewardPeriod` which returns delegators
     * that are fixed for the reward period of the block, this endpoint returns the
     * list of delegators that are registered in the block. Any changes to delegators
     * are immediately visible in this list.
     * The stream will end when all the delegators has been returned.
     *
     * {@codeblock ~~:nodejs/client/getPassiveDelegators.ts#documentation-snippet}
     *
     * @param blockHash an optional block hash to get the delegators at, otherwise retrieves from last finalized block.
     * @param abortSignal an optional AbortSignal to close the stream.
     * @returns a stream of DelegatorInfo
     */
    getPassiveDelegators(blockHash?: BlockHash.Type, abortSignal?: AbortSignal): AsyncIterable<v1.DelegatorInfo>;
    /**
     * Get the fixed passive delegators for the reward period of the given block.
     * In contracts to the `GetPassiveDelegators` which returns delegators registered
     * for the given block, this endpoint returns the fixed delegators contributing
     * stake in the reward period containing the given block.
     * The stream will end when all the delegators has been returned.
     *
     * {@codeblock ~~:nodejs/client/getPassiveDelegatorsRewardPeriod.ts#documentation-snippet}
     *
     * @param blockHash an optional block hash to get the delegators at, otherwise retrieves from last finalized block.
     * @param abortSignal an optional AbortSignal to close the stream.
     * @returns a stream of DelegatorRewardPeriodInfo
     */
    getPassiveDelegatorsRewardPeriod(blockHash?: BlockHash.Type, abortSignal?: AbortSignal): AsyncIterable<v1.DelegatorRewardPeriodInfo>;
    /**
     * Get the current branches of blocks starting from and including the last finalized block.
     *
     * {@codeblock ~~:nodejs/client/getBranches.ts#documentation-snippet}
     *
     * @returns a branch with a block hash and a list of branch-children
     */
    getBranches(): Promise<v1.Branch>;
    /**
     * Get information related to the baker election for a particular block.
     *
     * @param blockHash an optional block hash to get the election info at, otherwise retrieves from last finalized block.
     * @returns election info for the given block
     */
    getElectionInfo(blockHash?: BlockHash.Type): Promise<v1.ElectionInfo>;
    /**
     * Get a list of non-finalized transaction hashes for a given account. This
     * endpoint is not expected to return a large amount of data in most cases,
     * but in bad network conditions it might. The stream will end when all the
     * non-finalized transaction hashes have been returned.
     *
     * {@codeblock ~~:nodejs/client/getAccountNonFinalizedTransactions.ts#documentation-snippet}
     *
     * @param accountAddress The address of the account that you wish to query.
     * @returns a stream of transaction hashes.
     */
    getAccountNonFinalizedTransactions(accountAddress: AccountAddress.Type, abortSignal?: AbortSignal): AsyncIterable<TransactionHash.Type>;
    /**
     * Get a list of transaction events in a given block.
     * The stream will end when all the transaction events for a given block have been returned.
     *
     * {@codeblock ~~:nodejs/client/getBlockTransactionEvents.ts#documentation-snippet}
     *
     * @param blockHash an optional block hash to get the transaction events at, otherwise retrieves from last finalized block.
     * @param abortSignal an optional AbortSignal to close the stream.
     * @returns a stream of block item summaries
     */
    getBlockTransactionEvents(blockHash?: BlockHash.Type, abortSignal?: AbortSignal): AsyncIterable<BlockItemSummary>;
    /**
     * Get next available sequence numbers for updating chain parameters after a given block.
     *
     * {@codeblock ~~:nodejs/client/getNextUpdateSequenceNumbers.ts#documentation-snippet}
     *
     * @param blockHash an optional block hash to get the sequence numbers at, otherwise retrieves from last finalized block.
     * @return a NextUpdateSequenceNumbers object
     */
    getNextUpdateSequenceNumbers(blockHash?: BlockHash.Type): Promise<v1.NextUpdateSequenceNumbers>;
    /**
     * Shut down the node.
     * Return a GRPC error if the shutdown failed.
     *
     * {@codeblock ~~:nodejs/client/shutdown.ts#documentation-snippet}
     */
    shutdown(): Promise<void>;
    /**
     * Suggest to a peer to connect to the submitted peer details.
     * This, if successful, adds the peer to the list of given addresses.
     * Otherwise return a GRPC error.
     * Note. The peer might not be connected to instantly, in that case
     * the node will try to establish the connection in near future. This
     * function returns a GRPC status 'Ok' in this case.
     *
     * {@codeblock ~~:nodejs/client/peerConnect.ts#documentation-snippet}
     *
     * @param ip The ip address to connect to. Must be a valid ip address.
     * @param port The port to connect to. Must be between 0 and 65535.
     */
    peerConnect(ip: v1.IpAddressString, port: number): Promise<void>;
    /**
     * Disconnect from the peer and remove them from the given addresses list
     * if they are on it. Return if the request was processed successfully.
     * Otherwise return a GRPC error.
     *
     * {@codeblock ~~:nodejs/client/peerDisconnect.ts#documentation-snippet}
     *
     * @param ip The ip address to connect to. Must be a valid ip address.
     * @param port The port to connect to. Must be between 0 and 65535.
     */
    peerDisconnect(ip: v1.IpAddressString, port: number): Promise<void>;
    /**
     * Get a list of banned peers.
     *
     * {@codeblock ~~:nodejs/client/getBannedPeers.ts#documentation-snippet}
     *
     * @return A list of the ip's of banned peers.
     */
    getBannedPeers(): Promise<v1.IpAddressString[]>;
    /**
     * Ban the given peer.
     * Rejects if the action fails.
     *
     * {@codeblock ~~:nodejs/client/banPeer.ts#documentation-snippet}
     *
     * @param ip The ip address of the peer to ban. Must be a valid ip address.
     */
    banPeer(ip: v1.IpAddressString): Promise<void>;
    /**
     * Unbans the given peer.
     * Rejects if the action fails.
     *
     * {@codeblock ~~:nodejs/client/unbanPeer.ts#documentation-snippet}
     *
     * @param ip The ip address of the peer to unban. Must be a valid ip address.
     */
    unbanPeer(ip: v1.IpAddressString): Promise<void>;
    /**
     * Start dumping packages into the specified file.
     * Only enabled if the node was built with the `network_dump` feature.
     * Rejects if the network dump failed to start.
     *
     * {@codeblock ~~:nodejs/client/dumpStart.ts#documentation-snippet}
     *
     * @param filePath Which file to dump the packages into. Requires a valid path.
     * @param raw Whether the node should dump raw packages.
     */
    dumpStart(filePath: string, raw: boolean): Promise<void>;
    /**
     * Stop dumping packages.
     * Only enabled if the node was built with the `network_dump` feature.
     * Rejects if the network dump failed to be stopped.
     *
     * {@codeblock ~~:nodejs/client/dumpStop.ts#documentation-snippet}
     */
    dumpStop(): Promise<void>;
    /**
     * Get information about the node.
     * The `NodeInfo` includes information of
     * * Meta information such as the, version of the node, type of the node, uptime and the local time of the node.
     * * NetworkInfo which yields data such as the node id, packets sent/received,
     *   average bytes per second sent/received.
     * * ConsensusInfo. The `ConsensusInfo` returned depends on if the node supports
     *   the protocol on chain and whether the node is configured as a baker or not.
     *
     * {@codeblock ~~:nodejs/client/getNodeInfo.ts#documentation-snippet}
     *
     * @returns Info about the node
     */
    getNodeInfo(): Promise<v1.NodeInfo>;
    /**
     * Get a list of the peers that the node is connected to
     * and associated network related information for each peer.
     *
     * {@codeblock ~~:nodejs/client/getPeersInfo.ts#documentation-snippet}
     *
     * @returns a list containing info on each peer of the node.
     */
    getPeersInfo(): Promise<v1.PeerInfo[]>;
    /**
     * Get a list of special events in a given block. These are events generated
     * by the protocol, such as minting and reward payouts. They are not directly
     * generated by any transaction. The stream will end when all the special
     * events for a given block have been returned.
     *
     * {@codeblock ~~:nodejs/client/getBlockSpecialEvents.ts#documentation-snippet}
     *
     * @param blockHash an optional block hash to get the special events at, otherwise retrieves from last finalized block.
     * @param abortSignal an optional AbortSignal to close the stream.
     * @returns a stream of block item summaries
     */
    getBlockSpecialEvents(blockHash?: BlockHash.Type, abortSignal?: AbortSignal): AsyncIterable<v1.BlockSpecialEvent>;
    /**
     * Get the pending updates to chain parameters at the end of a given block.
     * The stream will end when all the pending updates for a given block have been returned.
     *
     * {@codeblock ~~:nodejs/client/getBlockPendingUpdates.ts#documentation-snippet}
     *
     * @param blockHash an optional block hash to get the pending updates at, otherwise retrieves from last finalized block.
     * @param abortSignal an optional AbortSignal to close the stream.
     * @returns a stream of pending updates
     */
    getBlockPendingUpdates(blockHash?: BlockHash.Type, abortSignal?: AbortSignal): AsyncIterable<v1.PendingUpdate>;
    /**
     * Get the summary of the finalization data in a given block.
     *
     * {@codeblock ~~:nodejs/client/getBlockFinalizationSummary.ts#documentation-snippet}
     *
     * @param blockHash an optional block hash to get the finalization summaries at, otherwise retrieves from last finalized block.
     * @returns a finalization summary
     */
    getBlockFinalizationSummary(blockHash?: BlockHash.Type): Promise<v1.BlockFinalizationSummary>;
    /**
     * Gets a stream of finalized blocks from specified `startHeight`.
     *
     * @param {bigint} [startHeight=0n] - An optional height to start streaming blocks from. Defaults to 0n.
     * @param {AbortSignal} [abortSignal] - An optional abort signal, which will end the stream. If this is not specified, the stream continues indefinitely.
     * @returns {AsyncIterable<v1.FinalizedBlockInfo>} A stream of {@link v1.FinalizedBlockInfo}.
     */
    getFinalizedBlocksFrom(startHeight: v1.AbsoluteBlocksAtHeightRequest, abortSignal?: AbortSignal): AsyncIterable<v1.FinalizedBlockInfo>;
    /**
     * Gets a stream of finalized blocks from specified `startHeight`.
     *
     * @param {bigint} [startHeight=0n] - An optional height to start streaming blocks from. Defaults to 0n.
     * @param {bigint} [endHeight] - An optional height to stop streaming at. If this is not specified, the stream continues indefinitely.
     * @returns {AsyncIterable<v1.FinalizedBlockInfo>} A stream of {@link v1.FinalizedBlockInfo}.
     */
    getFinalizedBlocksFrom(startHeight: v1.AbsoluteBlocksAtHeightRequest, endHeight?: v1.AbsoluteBlocksAtHeightRequest): AsyncIterable<v1.FinalizedBlockInfo>;
    /**
     * Find a block with lowest possible height where the predicate holds.
     * Note that this function uses binary search and is only intended to work for monotone predicates.
     *
     * @template R
     * @param {(bi: v1.FinalizedBlockInfo) => Promise<R | undefined>} predicate - A predicate function resolving with value of type {@link R} if the predicate holds, and undefined if not.
     * The precondition for this method is that the function is monotone, i.e., if block at height `h` satisfies the test then also a block at height `h+1` does.
     * If this precondition does not hold then the return value from this method is unspecified.
     * @param {bigint} [from=0n] - An optional lower bound of the range of blocks to search. Defaults to 0n.
     * @param {bigint} [to] - An optional upper bound of the range of blocks to search. Defaults to latest finalized block.
     *
     * @returns {Promise<R | undefined>} The value returned from `predicate` at the lowest block (in terms of height) where the predicate holds.
     */
    findEarliestFinalized<R>(predicate: (bi: v1.FinalizedBlockInfo) => Promise<R | undefined>, from?: v1.AbsoluteBlocksAtHeightRequest, to?: v1.AbsoluteBlocksAtHeightRequest): Promise<R | undefined>;
    /**
     * Find the block where a smart contract instance was created. This is a specialized form of {@link findEarliestFinalized}.
     *
     * @param {ContractAddress} address - The contract address to search for.
     * @param {bigint} [from=0n] - An optional lower bound of the range of blocks to search. Defaults to 0n.
     * @param {bigint} [to] - An optional upper bound of the range of blocks to search. Defaults to latest finalized block.
     *
     * @returns {FindInstanceCreationReponse} Information about the block and the contract instance, or undefined if not found.
     */
    findInstanceCreation(address: ContractAddress.Type, from?: v1.AbsoluteBlocksAtHeightRequest, to?: v1.AbsoluteBlocksAtHeightRequest): Promise<FindInstanceCreationReponse | undefined>;
    /**
     * Find the first block finalized after a given time.
     *
     * @param {Date} time - The time to find first block after
     * @param {bigint} [from=0n] - An optional lower bound of the range of blocks to search. Defaults to 0n.
     * @param {bigint} [to] - An optional upper bound of the range of blocks to search. Defaults to latest finalized block.
     *
     * @returns {v1.BlockInfo} Information about the block found, or undefined if no block was found.
     */
    findFirstFinalizedBlockNoLaterThan(time: Date, from?: v1.AbsoluteBlocksAtHeightRequest, to?: v1.AbsoluteBlocksAtHeightRequest): Promise<v1.BlockInfo | undefined>;
    /**
     * Get the projected earliest time at which a particular baker will be required to bake a block.
     *
     * If the baker is not a baker for the current reward period, this returns a timestamp at the
     * start of the next reward period. If the baker is a baker for the current reward period, the
     * earliest win time is projected from the current round forward, assuming that each round after
     * the last finalized round will take the minimum block time. (If blocks take longer, or timeouts
     * occur, the actual time may be later, and the reported time in subsequent queries may reflect
     * this.) At the end of an epoch (or if the baker is not projected to bake before the end of the
     * epoch) the earliest win time for a (current) baker will be projected as the start of the next
     * epoch. This is because the seed for the leader election is updated at the epoch boundary, and
     * so the winners cannot be predicted beyond that. Note that in some circumstances the returned
     * timestamp can be in the past, especially at the end of an epoch.
     *
     * @throws an `UNAVAILABLE` RPC error if the current consensus version is 0 (prior to protocol version 6), as the endpoint is only supported from consensus version 1 (from protocol version 6).
     *
     * @param {v1.BakerId} baker - The baker that should be queried for.
     *
     * @returns {Timestamp.Type} The projected earliest time at which a particular baker will be required to bake a block, as a unix timestamp in milliseconds.
     */
    getBakerEarliestWinTime(baker: v1.BakerId): Promise<Timestamp.Type>;
    /**
     * For a non-genesis block, this returns the quorum certificate, a timeout
     * certificate (if present) and epoch finalization entry (if present).
     *
     * @throws an `UNIMPLEMENTED` RPC error if the endpoint is not enabled by the node.
     * @throws an `INVALID_ARGUMENT` if the block being pointed to is not a product of ConcordiumBFT
     *
     * @param blockHash optional block hash to get the cryptographic parameters at, otherwise retrieves from last finalized block.
     *
     * @returns the requested block certificates.
     */
    getBlockCertificates(blockHash?: BlockHash.Type): Promise<v1.BlockCertificates>;
    /**
     * Get all bakers in the reward period of a block.
     * This endpoint is only supported for protocol version 6 and onwards.
     *
     * @throws an `IllegalArgument` RPC error if the protocol does not support the endpoint.
     *
     * @param blockHash optional block hash to get the cryptographic parameters at, otherwise retrieves from last finalized block.
     *
     * @returns All bakers in the reward period of a block
     */
    getBakersRewardPeriod(blockHash?: BlockHash.Type): AsyncIterable<v1.BakerRewardPeriodInfo>;
    /**
     * Get the list of bakers that won the lottery in a particular historical epoch (i.e. the
     * last finalized block is in a later epoch). This lists the winners for each round in the
     * epoch, starting from the round after the last block in the previous epoch, running to
     * the round before the first block in the next epoch. It also indicates if a block in each
     * round was included in the finalized chain.
     *
     * The following error cases are possible:
     * @throws a `NOT_FOUND` RPC error if the query specifies an unknown block.
     * @throws an `UNAVAILABLE` RPC error if the query is for an epoch that is not finalized in the current genesis index, or is for a future genesis index.
     * @throws an `INVALID_ARGUMENT` RPC error if the query is for an epoch that is not finalized for a past genesis index.
     * @throws an `INVALID_ARGUMENT` RPC error if the query is for a genesis index at consensus version 0.
     * @throws an `INVALID_ARGUMENT` RPC error if the input `EpochRequest` is malformed.
     * @throws an `UNAVAILABLE` RPC error if the endpoint is disabled on the node.
     *
     * @param {BlockHash.Type | v1.RelativeEpochRequest } epochRequest - Consists of either a block hash or a relative epoch request consisting of a genesis index and an epoch. If none is passed, it queries the last finalized block.
     *
     * @returns {v1.WinningBaker} A stream of winning bakers for a given epoch.
     */
    getWinningBakersEpoch(epochRequest?: BlockHash.Type | v1.RelativeEpochRequest): AsyncIterable<v1.WinningBaker>;
    /**
     * Get the block hash of the first finalized block in a specified epoch.
     *
     * The following error cases are possible:
     * @throws - a `NOT_FOUND` RPC error if the query specifies an unknown block.
     * @throws - an `UNAVAILABLE` RPC error if the query is for an epoch that is not finalized in the current genesis index, or is for a future genesis index.
     * @throws - an `INVALID_ARGUMENT` RPC error if the query is for an epoch with no finalized blocks for a past genesis index.
     * @throws - an `INVALID_ARGUMENT` RPC error if the input `EpochRequest` is malformed.
     * @throws - an `UNAVAILABLE` RPC error if the endpoint is disabled on the node.
     *
     * @param {BlockHash.Type | v1.RelativeEpochRequest } epochRequest - Consists of either a block hash or a relative epoch request consisting of a genesis index and an epoch. If none is passed, it queries the last finalized block.
     *
     * @returns {HexString} The block hash as a hex encoded string.
     */
    getFirstBlockEpoch(epochRequest?: BlockHash.Type | v1.RelativeEpochRequest): Promise<BlockHash.Type>;
    private getConsensusHeight;
    /**
     * Queries the node to check its health
     *
     * {@codeblock ~~:nodejs/client/healthCheck.ts#documentation-snippet}
     *
     * @returns a HealthCheck indicating whether the node is healthy or not and provides the message from the client, if not healthy.
     */
    healthCheck(): Promise<v1.HealthCheckResponse>;
}
/**
 * @hidden
 */
export declare function getBlockHashInput(blockHash?: BlockHash.Type): v2.BlockHashInput;
/**
 * @hidden
 */
export declare function getAccountIdentifierInput(accountIdentifier: v1.AccountIdentifierInput): v2.AccountIdentifierInput;
/**
 * A concordium-node specific gRPC client wrapper, using a grpc-web transport layer.
 * This requires that the node at the address supplied has grpc-web enabled.
 *
 * @example
 * import { ConcordiumGRPCWebClient } from "..."
 * const client = new ConcordiumGRPCWebClient('127.0.0.1', 20000);
 */
export declare class ConcordiumGRPCWebClient extends ConcordiumGRPCClient {
    constructor(address: string, port: number, options?: Partial<GrpcWebOptions>);
}
/**
 * @hidden
 */
export declare function getInvokerInput(invoker?: AccountAddress.Type | ContractAddress.Type): v2.Address | undefined;
