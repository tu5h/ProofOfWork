import { Buffer } from 'buffer/index.js';
import { ContractAddress, ContractName, Energy, ModuleReference } from './pub/types.js';
import { serializeCredentialDeploymentInfo } from './serialization.js';
import { encodeDataBlob, encodeWord8, encodeWord32, encodeWord64, packBufferWithWord16Length, packBufferWithWord32Length, serializeConfigureBakerPayload, serializeConfigureDelegationPayload, serializeList, } from './serializationHelpers.js';
import { AccountTransactionType, DelegationTargetType, } from './types.js';
import * as AccountAddress from './types/AccountAddress.js';
import * as CcdAmount from './types/CcdAmount.js';
import { DataBlob } from './types/DataBlob.js';
import * as Parameter from './types/Parameter.js';
import * as ReceiveName from './types/ReceiveName.js';
export class SimpleTransferHandler {
    getBaseEnergyCost() {
        return 300n;
    }
    serialize(transfer) {
        const serializedToAddress = AccountAddress.toBuffer(transfer.toAddress);
        const serializedAmount = encodeWord64(transfer.amount.microCcdAmount);
        return Buffer.concat([serializedToAddress, serializedAmount]);
    }
    deserialize(serializedPayload) {
        const toAddress = AccountAddress.fromBuffer(Buffer.from(serializedPayload.read(32)));
        const amount = CcdAmount.fromMicroCcd(serializedPayload.read(8).readBigUInt64BE(0));
        return {
            toAddress,
            amount,
        };
    }
    toJSON(transfer) {
        return {
            toAddress: transfer.toAddress.toJSON(),
            amount: transfer.amount.toJSON(),
        };
    }
    fromJSON(json) {
        return {
            toAddress: AccountAddress.fromJSON(json.toAddress),
            amount: CcdAmount.fromJSON(json.amount),
        };
    }
}
export class SimpleTransferWithMemoHandler extends SimpleTransferHandler {
    serialize(transfer) {
        const serializedToAddress = AccountAddress.toBuffer(transfer.toAddress);
        const serializedMemo = encodeDataBlob(transfer.memo);
        const serializedAmount = encodeWord64(transfer.amount.microCcdAmount);
        return Buffer.concat([serializedToAddress, serializedMemo, serializedAmount]);
    }
    deserialize(serializedPayload) {
        const toAddress = AccountAddress.fromBuffer(Buffer.from(serializedPayload.read(32)));
        const memoLength = serializedPayload.read(2).readUInt16BE(0);
        const memo = new DataBlob(Buffer.from(serializedPayload.read(memoLength)));
        const amount = CcdAmount.fromMicroCcd(serializedPayload.read(8).readBigUInt64BE(0));
        return {
            toAddress,
            memo,
            amount,
        };
    }
    toJSON(transfer) {
        return {
            toAddress: transfer.toAddress.toJSON(),
            memo: transfer.memo.toJSON(),
            amount: transfer.amount.toJSON(),
        };
    }
    fromJSON(json) {
        return {
            toAddress: AccountAddress.fromJSON(json.toAddress),
            memo: DataBlob.fromJSON(json.memo),
            amount: CcdAmount.fromJSON(json.amount),
        };
    }
}
export class DeployModuleHandler {
    getBaseEnergyCost(payload) {
        let length = payload.source.byteLength;
        if (payload.version === undefined) {
            // Remove the 8 bytes from the embedded version and length.
            length -= 8;
        }
        const cost = Math.floor(length / 10);
        return BigInt(cost);
    }
    serialize(payload) {
        if (payload.version === undefined) {
            // Assume the module has version and length embedded
            return Buffer.from(payload.source);
        }
        else {
            // Assume the module is legacy build, which doesn't contain version and length
            const serializedWasm = packBufferWithWord32Length(payload.source);
            const serializedVersion = encodeWord32(payload.version);
            return Buffer.concat([serializedVersion, serializedWasm]);
        }
    }
    deserialize() {
        throw new Error('deserialize not supported');
    }
    toJSON(payload) {
        return {
            source: Buffer.from(payload.source).toString('hex'),
            version: payload.version,
        };
    }
    fromJSON(json) {
        return {
            source: Buffer.from(json.source, 'hex'),
            version: json.version !== undefined ? Number(json.version) : undefined,
        };
    }
}
export class InitContractHandler {
    getBaseEnergyCost(payload) {
        return payload.maxContractExecutionEnergy.value;
    }
    serialize(payload) {
        const serializedAmount = encodeWord64(payload.amount.microCcdAmount);
        const initNameBuffer = Buffer.from('init_' + payload.initName.value, 'utf8');
        const serializedInitName = packBufferWithWord16Length(initNameBuffer);
        const serializedModuleRef = payload.moduleRef.decodedModuleRef;
        const parameterBuffer = Parameter.toBuffer(payload.param);
        const serializedParameters = packBufferWithWord16Length(parameterBuffer);
        return Buffer.concat([serializedAmount, serializedModuleRef, serializedInitName, serializedParameters]);
    }
    deserialize() {
        throw new Error('deserialize not supported');
    }
    toJSON(payload) {
        return {
            amount: payload.amount.toJSON(),
            moduleRef: payload.moduleRef.toJSON(),
            initName: payload.initName.toJSON(),
            param: payload.param.toJSON(),
            maxContractExecutionEnergy: payload.maxContractExecutionEnergy.value,
        };
    }
    fromJSON(json) {
        return {
            amount: CcdAmount.fromJSON(json.amount),
            moduleRef: ModuleReference.fromJSON(json.moduleRef),
            initName: ContractName.fromJSON(json.initName),
            param: Parameter.fromJSON(json.param),
            maxContractExecutionEnergy: Energy.create(json.maxContractExecutionEnergy),
        };
    }
}
export class UpdateContractHandler {
    getBaseEnergyCost(payload) {
        return payload.maxContractExecutionEnergy.value;
    }
    serialize(payload) {
        const serializedAmount = encodeWord64(payload.amount.microCcdAmount);
        const serializeIndex = encodeWord64(payload.address.index);
        const serializeSubindex = encodeWord64(payload.address.subindex);
        const serializedContractAddress = Buffer.concat([serializeIndex, serializeSubindex]);
        const receiveNameBuffer = Buffer.from(ReceiveName.toString(payload.receiveName), 'utf8');
        const serializedReceiveName = packBufferWithWord16Length(receiveNameBuffer);
        const parameterBuffer = Parameter.toBuffer(payload.message);
        const serializedParameters = packBufferWithWord16Length(parameterBuffer);
        return Buffer.concat([
            serializedAmount,
            serializedContractAddress,
            serializedReceiveName,
            serializedParameters,
        ]);
    }
    deserialize() {
        throw new Error('deserialize not supported');
    }
    toJSON(payload) {
        return {
            amount: payload.amount.toJSON(),
            address: ContractAddress.toSchemaValue(payload.address),
            receiveName: payload.receiveName.toJSON(),
            message: payload.message.toJSON(),
            maxContractExecutionEnergy: payload.maxContractExecutionEnergy.value,
        };
    }
    fromJSON(json) {
        return {
            amount: CcdAmount.fromJSON(json.amount),
            address: ContractAddress.fromSchemaValue(json.address),
            receiveName: ReceiveName.fromJSON(json.receiveName),
            message: Parameter.fromJSON(json.message),
            maxContractExecutionEnergy: Energy.create(json.maxContractExecutionEnergy),
        };
    }
}
export class UpdateCredentialsHandler {
    getBaseEnergyCost(updateCredentials) {
        const newCredentialsCost = updateCredentials.newCredentials
            .map((credential) => {
            const numberOfKeys = BigInt(Object.keys(credential.cdi.credentialPublicKeys.keys).length);
            return 54000n + 100n * numberOfKeys;
        })
            .reduce((prev, curr) => prev + curr, BigInt(0));
        const currentCredentialsCost = 500n * updateCredentials.currentNumberOfCredentials;
        return 500n + currentCredentialsCost + newCredentialsCost;
    }
    serialize(updateCredentials) {
        const serializedAddedCredentials = serializeList(updateCredentials.newCredentials, encodeWord8, ({ index, cdi }) => Buffer.concat([encodeWord8(index), serializeCredentialDeploymentInfo(cdi)]));
        const serializedRemovedCredIds = serializeList(updateCredentials.removeCredentialIds, encodeWord8, (credId) => Buffer.from(credId, 'hex'));
        const serializedThreshold = encodeWord8(updateCredentials.threshold);
        return Buffer.concat([serializedAddedCredentials, serializedRemovedCredIds, serializedThreshold]);
    }
    deserialize() {
        throw new Error('deserialize not supported');
    }
    toJSON(updateCredentials) {
        return updateCredentials;
    }
    fromJSON(json) {
        return {
            ...json,
            currentNumberOfCredentials: BigInt(json.currentNumberOfCredentials),
            threshold: Number(json.threshold),
            newCredentials: json.newCredentials.map((nc) => ({
                index: Number(nc.index),
                cdi: {
                    ...nc.cdi,
                    credentialPublicKeys: {
                        ...nc.cdi.credentialPublicKeys,
                        threshold: Number(nc.cdi.credentialPublicKeys.threshold),
                    },
                    ipIdentity: Number(nc.cdi.ipIdentity),
                    revocationThreshold: Number(nc.cdi.revocationThreshold),
                },
            })),
        };
    }
}
export class RegisterDataHandler {
    getBaseEnergyCost() {
        return 300n;
    }
    serialize(payload) {
        return encodeDataBlob(payload.data);
    }
    deserialize(serializedPayload) {
        const memoLength = serializedPayload.read(2).readUInt16BE(0);
        return {
            data: new DataBlob(Buffer.from(serializedPayload.read(memoLength))),
        };
    }
    toJSON(payload) {
        return {
            data: payload.data.toJSON(),
        };
    }
    fromJSON(json) {
        return {
            // The first 2 bytes are the length of the data buffer, so we need to remove them.
            data: DataBlob.fromJSON(json.data),
        };
    }
}
export class ConfigureBakerHandler {
    getBaseEnergyCost(payload) {
        if (payload.keys) {
            return 4050n;
        }
        else {
            return 300n;
        }
    }
    serialize(payload) {
        return serializeConfigureBakerPayload(payload);
    }
    deserialize() {
        throw new Error('deserialize not supported');
    }
    toJSON(payload) {
        return {
            ...payload,
            stake: payload.stake?.toJSON(),
        };
    }
    fromJSON(json) {
        return {
            ...json,
            stake: json.stake ? CcdAmount.fromJSON(json.stake) : undefined,
            openForDelegation: json.openForDelegation !== undefined ? Number(json.openForDelegation) : undefined,
            transactionFeeCommission: json.transactionFeeCommission !== undefined ? Number(json.transactionFeeCommission) : undefined,
            bakingRewardCommission: json.bakingRewardCommission !== undefined ? Number(json.bakingRewardCommission) : undefined,
            finalizationRewardCommission: json.finalizationRewardCommission !== undefined ? Number(json.finalizationRewardCommission) : undefined,
        };
    }
}
export class ConfigureDelegationHandler {
    getBaseEnergyCost() {
        return 300n;
    }
    serialize(payload) {
        return serializeConfigureDelegationPayload(payload);
    }
    deserialize() {
        throw new Error('deserialize not supported');
    }
    toJSON(payload) {
        return {
            ...payload,
            stake: payload.stake?.toJSON(),
        };
    }
    fromJSON(json) {
        let result = {
            ...json,
            stake: json.stake ? CcdAmount.fromJSON(json.stake) : undefined,
        };
        if (json.delegationTarget === undefined ||
            json.delegationTarget.delegateType === DelegationTargetType.PassiveDelegation) {
            return result;
        }
        result.delegationTarget = { ...json.delegationTarget, bakerId: BigInt(json.delegationTarget.bakerId) };
        return result;
    }
}
export function getAccountTransactionHandler(type
// eslint-disable-next-line @typescript-eslint/no-explicit-any
) {
    switch (type) {
        case AccountTransactionType.Transfer:
            return new SimpleTransferHandler();
        case AccountTransactionType.TransferWithMemo:
            return new SimpleTransferWithMemoHandler();
        case AccountTransactionType.DeployModule:
            return new DeployModuleHandler();
        case AccountTransactionType.InitContract:
            return new InitContractHandler();
        case AccountTransactionType.Update:
            return new UpdateContractHandler();
        case AccountTransactionType.UpdateCredentials:
            return new UpdateCredentialsHandler();
        case AccountTransactionType.RegisterData:
            return new RegisterDataHandler();
        case AccountTransactionType.ConfigureDelegation:
            return new ConfigureDelegationHandler();
        case AccountTransactionType.ConfigureBaker:
            return new ConfigureBakerHandler();
        default:
            throw new Error('The provided type does not have a handler: ' + type);
    }
}
//# sourceMappingURL=accountTransactions.js.map